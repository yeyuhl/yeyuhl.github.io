<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统导论期末复习 | 随便写写</title><meta name="author" content="夜语"><meta name="copyright" content="夜语"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="操作系统导论期末复习 教材：《操作系统导论》  一、操作系统介绍什么是操作系统：操作系统是管理计算机硬件与软件资源的计算机程序，提供其他程序和硬件之间的接口，对需求进行管理，对资源进行分配，对用户提供服务，是计算机中软件和硬件的总指挥部。本书围绕三大主题：虚拟化，并发，持久性展开讨论。 1.虚拟化CPU在硬件的一些帮助下，操作系统负责提供这种假象（illusion），即系统拥有非常多的虚拟CPU的">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统导论期末复习">
<meta property="og:url" content="https://yeyuhl.github.io/2023/05/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="随便写写">
<meta property="og:description" content="操作系统导论期末复习 教材：《操作系统导论》  一、操作系统介绍什么是操作系统：操作系统是管理计算机硬件与软件资源的计算机程序，提供其他程序和硬件之间的接口，对需求进行管理，对资源进行分配，对用户提供服务，是计算机中软件和硬件的总指挥部。本书围绕三大主题：虚拟化，并发，持久性展开讨论。 1.虚拟化CPU在硬件的一些帮助下，操作系统负责提供这种假象（illusion），即系统拥有非常多的虚拟CPU的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/%E7%89%B9%E5%AE%9A%E6%96%87%E4%BB%B6/1a14e4eeedd428147c921881097b3aed8a932201.jpg%40942w_942h_progressive.webp">
<meta property="article:published_time" content="2023-05-01T11:23:47.000Z">
<meta property="article:modified_time" content="2023-09-13T08:10:49.850Z">
<meta property="article:author" content="夜语">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/%E7%89%B9%E5%AE%9A%E6%96%87%E4%BB%B6/1a14e4eeedd428147c921881097b3aed8a932201.jpg%40942w_942h_progressive.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yeyuhl.github.io/2023/05/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统导论期末复习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-13 16:10:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/%E7%89%B9%E5%AE%9A%E6%96%87%E4%BB%B6/1a14e4eeedd428147c921881097b3aed8a932201.jpg%40942w_942h_progressive.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/%E7%89%B9%E5%AE%9A%E6%96%87%E4%BB%B6/wallhaven-p9woe3.png')"><nav id="nav"><span id="blog-info"><a href="/" title="随便写写"><span class="site-name">随便写写</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统导论期末复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-01T11:23:47.000Z" title="发表于 2023-05-01 19:23:47">2023-05-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-13T08:10:49.850Z" title="更新于 2023-09-13 16:10:49">2023-09-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E6%80%BB%E5%A4%8D%E4%B9%A0/">课程总复习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统导论期末复习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="操作系统导论期末复习"><a href="#操作系统导论期末复习" class="headerlink" title="操作系统导论期末复习"></a>操作系统导论期末复习</h1><blockquote>
<p>教材：《操作系统导论》</p>
</blockquote>
<h2 id="一、操作系统介绍"><a href="#一、操作系统介绍" class="headerlink" title="一、操作系统介绍"></a>一、操作系统介绍</h2><p>什么是操作系统：操作系统是管理计算机硬件与软件资源的计算机程序，提供其他程序和硬件之间的接口，对需求进行管理，对资源进行分配，对用户提供服务，是计算机中软件和硬件的总指挥部。本书围绕三大主题：<strong>虚拟化，并发，持久性</strong>展开讨论。</p>
<h3 id="1-虚拟化CPU"><a href="#1-虚拟化CPU" class="headerlink" title="1.虚拟化CPU"></a>1.虚拟化CPU</h3><p>在硬件的一些帮助下，操作系统负责提供这种假象（illusion），即系统拥有非常多的虚拟CPU的假象。将单个CPU（或其中一小部分）转换为看似无限数量的CPU，从而让许多程序看似同时运行，这就是所谓的虚拟化CPU（virtualizing the CPU）。一次运行多个程序的能力会引发各种新问题。例如，如果两个程序想要在特定时间运行，应该运行哪个？这个问题由操作系统的策略（policy）来回答。</p>
<h3 id="2-虚拟化内存"><a href="#2-虚拟化内存" class="headerlink" title="2.虚拟化内存"></a>2.虚拟化内存</h3><p>每个进程访问自己的私有虚拟地址空间（virtual address space）（有时称为地址空间，address space），操作系统以某种方式映射到机器的物理内存上。一个正在运行的程序中的内存引用不会影响其他进程（或操作系统本身）的地址空间。对于正在运行的程序，它完全拥有自己的物理内存。</p>
<h3 id="3-并发"><a href="#3-并发" class="headerlink" title="3.并发"></a>3.并发</h3><p>当有多个线程在操作时，如果系统只有一个CPU，则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。这种方式我们称之为并发(Concurrent)。</p>
<h3 id="4-持久性"><a href="#4-持久性" class="headerlink" title="4.持久性"></a>4.持久性</h3><p>在系统内存中，数据容易丢失，因为像DRAM这样的设备以易失（volatile）的方式存储数值。如果断电或系统崩溃，那么内存中的所有数据都会丢失。因此，我们需要硬件和软件来持久地（persistently）存储数据。这样的存储对于所有系统都很重要，因为用户非常关心他们的数据。硬件以某种输入&#x2F;输出（Input&#x2F;Output，I&#x2F;O）设备的形式出现。在现代系统中，硬盘驱动器（hard drive）是存储长期保存的信息的通用存储库。</p>
<h2 id="二、抽象：进程"><a href="#二、抽象：进程" class="headerlink" title="二、抽象：进程"></a>二、抽象：进程</h2><p>操作系统提供的基本的抽象——进程。进程的非正式定义非常简单：进程就是运行中的程序。人们希望能同时运行多个程序，操作系统中可能有上百个进程在运行，但CPU是有限的。通过让一个进程只运行一个时间片，然后切换到其他进程，操作系统提供了存在多个虚拟 CPU 的假象。这就是时分共享CPU技术。</p>
<h3 id="1-进程创建"><a href="#1-进程创建" class="headerlink" title="1.进程创建"></a>1.进程创建</h3><p>运行程序第一步是将代码和所有静态数据（例如初始化变量）加载（load）到内存中，加载到进程的地址空间中。在早期的（或简单的）操作系统中，加载过程尽早（eagerly）完成，即在运行程序之前全部完成。现代操作系统惰性（lazily）执行该过程，即仅在程序执行期间需要加载的代码或数据片段，才会加载。</p>
<p>将代码和静态数据加载到内存后，操作系统在运行此进程之前还需要执行其他一些操作。比如为程序的运行时栈（run-time stack 或 stack）分配一些内存，为程序的堆（heap）分配一些内存，还将执行一些其他初始化任务，特别是与输入&#x2F;输出（I&#x2F;O）相关的任务。<br>最后一步就是启动程序，在入口处运行，即main()。通过跳转到main()例程（第 5 章讨论的专门机制），OS将CPU的控制权转移到新创建的进程中，从而程序开始执行。</p>
<h3 id="2-进程状态"><a href="#2-进程状态" class="headerlink" title="2.进程状态"></a>2.进程状态</h3><p>进程在给定时间可能处于的不同状态（state），一般来说进程处于以下三种状态之一：<strong>运行，就绪，阻塞</strong>。<br><strong>运行（running）</strong>：在运行状态下，进程正在处理器上运行。这意味着它正在执行指令。<br><strong>就绪（ready）</strong>：在就绪状态下，进程已准备好运行，但由于某种原因，操作系统选择不在此时运行。<br><strong>阻塞（blocked）</strong>：在阻塞状态下，一个进程执行了某种操作，直到发生其他事件时才会准备运行。一个常见的例子是，当进程向磁盘发起 I&#x2F;O 请求时，它会被阻塞，因此其他进程可以使用处理器。<br>从就绪到运行意味着该进程已经被调度（scheduled）。从运行转移到就绪意味着该进程已经取消调度（descheduled）。一旦进程被阻塞（例如，通过发起 I&#x2F;O 操作），OS 将保持进程的这种状态，直到发生某种事件（例如，I&#x2F;O 完成）。</p>
<h3 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3.数据结构"></a>3.数据结构</h3><p>操作系统是一个程序，和其他程序一样，它有一些关键的数据结构来跟踪各种相关的信息。例如，为了跟踪每个进程的状态，操作系统可能会为所有就绪的进程保留某种进程列表（process list），以及跟踪当前正在运行的进程的一些附加信息。操作系统还必须以某种方式跟踪被阻塞的进程。当 I&#x2F;O 事件完成时，操作系统应确保唤醒正确的进程，让它准备好再次运行。</p>
<p>对于停止的进程，寄存器上下文将保存其寄存器的内容。当一个进程停止时，它的寄存器将被保存到这个内存位置。通过恢复这些寄存器（将它们的值放回实际的物理寄存器中），操作系统可以恢复运行该进程。我们将在后面的章节中更多地了解这种技术，它被称为<strong>上下文切换</strong>（context switch）。</p>
<h2 id="三、插叙：进程API"><a href="#三、插叙：进程API" class="headerlink" title="三、插叙：进程API"></a>三、插叙：进程API</h2><p>本章将讨论 UNIX 系统中的进程创建。UNIX 系统采用了一种非常有趣的创建新进程的方式，即通过一对系统调用：fork()和 exec()。进程还可以通过第三个系统调用 wait()，来等待其创建的子进程执行完成。本章将详细介绍这些接口，通过一些简单的例子来激发兴趣。</p>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><p>fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：<br>（1）在父进程中，fork返回新创建子进程的进程ID；<br>（2）在子进程中，fork返回0；<br>（3）如果出现错误，fork返回一个负值；<br>在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。子进程并非是完全拷贝了父进程，它拥有自己的地址空间（即拥有自己的私有内存）、寄存器、程序计数器等。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。两个进程的运行先后有CPU调度程序决定，并不是父进程一定先于子进程执行。</p>
<h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><p>wait能使当前进程延后运行，当另一个进程完成后再运行。比如前面fork之后，父子进程的运行先后不是固定的，但是如果在父进程中调用wait，延迟自己的运行，直到子进程执行完毕。当子进程结束时，wait才返回父进程，父进程再执行，此时运行的先后就是固定的了。</p>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><p>exec系统调用能让子进程执行与父进程不同的程序。给定可执行程序的名称（如 wc）及需要的参数（如 p3.c）后，exec()会从可执行程序中加载代码和静态数据，并用它覆写自己的代码段（以及静态数据），堆、栈及其他内存空间也会被重新初始化。然后操作系统就执行该程序，将参数通过 argv 传递给该进程。因此，它并没有创建新进程，而是直接将当前运行的程序（以前的 p3）替换为不同的运行程序（wc）。子进程执行 exec之后，几乎就像p3.c 从未运行过一样。对 exec的成功调用永远不会返回。</p>
<h2 id="四、机制：受限直接执行"><a href="#四、机制：受限直接执行" class="headerlink" title="四、机制：受限直接执行"></a>四、机制：受限直接执行</h2><p>为了虚拟化 CPU，操作系统需要以某种方式让许多任务共享物理 CPU，让它们看起来像是同时运行。基本思想很简单：运行一个进程一段时间，然后运行另一个进程，如此轮换。通过以这种方式时分共享（time sharing）CPU，就实现了虚拟化。但性能和控制权是实现这个虚拟化机制所要解决的问题，尤其是控制权，要保证进程不能无限制地运行并接管机器，或访问没有权限的信息。因此，要力求保持控制权的同时获得高性能。</p>
<h3 id="问题-1：受限制的操作"><a href="#问题-1：受限制的操作" class="headerlink" title="问题 1：受限制的操作"></a>问题 1：受限制的操作</h3><p>用户模式：应用程序不能完全访问硬件资源，如发出I&#x2F;O请求。<br>内核模式：操作系统就以这种模式运行，可以访问机器的全部资源。<br>用户希望执行某种特权操作，这时候操作系统提供用户程序执行系统调用的能力，来完成某些特权操作，而执行系统调用则要执行特殊的陷阱指令，从用户模式进入内核模式，完成所需要的特权操作后，操作系统调用一个特殊的从陷阱返回的指令，从内核模式回到用户模式，返回到发起调用的用户程序中。</p>
<h3 id="问题-2：在进程之间切换"><a href="#问题-2：在进程之间切换" class="headerlink" title="问题 2：在进程之间切换"></a>问题 2：在进程之间切换</h3><p>在进程之间切换，此时操作系统并没有在CPU上运行，所以由操作系统执行进程间切换成了问题。</p>
<h4 id="协作方式：等待系统调用"><a href="#协作方式：等待系统调用" class="headerlink" title="协作方式：等待系统调用"></a>协作方式：等待系统调用</h4><p>在这种方式下，操作系统相信系统的进程会合理运行。运行时间过长的进程被假定会定期放弃CPU，以便操作系统可以决定运行其他任务。大多数进程通过进行系统调用，将 CPU 的控制权转移给操作系统，例如打开文件并随后读取文件，或者向另一台机器发送消息或创建新进程。像这样的系统通常包括一个显式的 yield 系统调用，它什么都不干，只是将控制权交给操作系统，以便系统可以运行其他进程。</p>
<h4 id="非协作方式：操作系统进行控制"><a href="#非协作方式：操作系统进行控制" class="headerlink" title="非协作方式：操作系统进行控制"></a>非协作方式：操作系统进行控制</h4><p>事实证明，没有硬件的额外帮助，如果进程拒绝进行系统调用（也不出错），从而将控制权交还给操作系统，那么操作系统无法做任何事情。因此通过时钟设备编程为每隔几毫秒产生一次中断，产生中断时当前正在运行的进程停止，操作系统中预先配置的中断处理程序（interrupt handler）会运行。此时，操作系统重新获得 CPU 的控制权，因此可以做它想做的事：停止当前进程，并启动另一个进程。</p>
<h4 id="保存和恢复上下文"><a href="#保存和恢复上下文" class="headerlink" title="保存和恢复上下文"></a>保存和恢复上下文</h4><p>如果决定进行切换，OS 就会执行一些底层代码，即所谓的上下文切换（context switch）。上下文切换在概念上很简单：操作系统要做的就是为当前正在执行的进程保存一些寄存器的值（例如，到它的内核栈），并为即将执行的进程恢复一些寄存器的值（从它的内核栈）。这样一来，操作系统就可以确保最后执行从陷阱返回指令时，不是返回到之前运行的进程，而是继续执行另一个进程。</p>
<h2 id="五、进程调度：介绍"><a href="#五、进程调度：介绍" class="headerlink" title="五、进程调度：介绍"></a>五、进程调度：介绍</h2><p>事实上，调度的起源早于计算机系统。早期调度策略取自于操作管理领域，并应用于计算机。</p>
<h3 id="工作负载假设"><a href="#工作负载假设" class="headerlink" title="工作负载假设"></a>工作负载假设</h3><p>我们对操作系统中运行的进程（有时也叫工作任务）做出如下的假设：<br>①每一个工作运行相同的时间。<br>②所有的工作同时到达。<br>③一旦开始，每个工作保持运行直到完成。<br>④所有的工作只是用 CPU（即它们不执行 IO 操作）。<br>⑤每个工作的运行时间是已知的。</p>
<h3 id="调度指标"><a href="#调度指标" class="headerlink" title="调度指标"></a>调度指标</h3><p>周转时间：任务完成时间减去任务到达系统的时间，$T_{周转}&#x3D;T_{完成}-T_{到达}$。（性能）<br>响应时间：从任务到达系统到首次运行的时间，$T_{响应}&#x3D;T_{首次}-T_{到达}$。（交互性）</p>
<h3 id="四种调度策略"><a href="#四种调度策略" class="headerlink" title="四种调度策略"></a>四种调度策略</h3><p>从周转时间下考虑：<br><strong>FIFO</strong>：先进先出，好处在于简单并易于实现，坏处在于容易造成护航效应。<br><strong>SJF</strong>：最短任务优先，先运行最短的任务，然后是次短的任务，如此下去。（任务必须完成才能完成下一个）<br><strong>STCF</strong>：最短完成时间优先，每当新工作进入系统时，它就会确定剩余工作和新工作中，谁的剩余时间最少，然后调度该工作。<br>从响应时间下考虑：<br><strong>RR</strong>：轮转调度，在一个时间片（time slice，有时称为调度量子，scheduling quantum）内运行一个工作，然后切换到运行队列中的下一个任务，而不是运行一个任务直到结束。它反复执行，直到所有任务完成。时间片越短，RR在响应时间上表现越好，但频繁的突然上下文切换的成本将会影响整体性能，因此要权衡时间片长度。</p>
<p>我们开发了两种调度程序。第一种类型（SJF、STCF）优化周转时间，但对响应时间不利。第二种类型（RR）优化响应时间，但对周转时间不利。我们还有两个假设需要放宽：假设 4（作业没有 I&#x2F;O）和假设 5（每个作业的运行时间是已知的）。接下来我们来解决这些假设。</p>
<h3 id="结合I-x2F-O"><a href="#结合I-x2F-O" class="headerlink" title="结合I&#x2F;O"></a>结合I&#x2F;O</h3><p>利用重叠思想：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo/20230502150005.png"></p>
<h3 id="调度：多级反馈队列"><a href="#调度：多级反馈队列" class="headerlink" title="调度：多级反馈队列"></a>调度：多级反馈队列</h3><p>多级反馈队列需要解决两方面的问题。首先，它要优化周转时间。在第 7 章中我们看到，这通过先执行短工作来实现。然而，操作系统通常不知道工作要运行多久，而这又是SJF（或 STCF）等算法所必需的。其次，MLFQ 希望给交互用户（如用户坐在屏幕前，等着进程结束）很好的交互体验，因此需要降低响应时间。然而，像轮转这样的算法虽然降低了响应时间，周转时间却很差。</p>
<p>MLFQ中有许多独立的队列（queue），每个队列有不同的优先级（priority level）。任何时刻，一个工作只能存在于一个队列中。MLFQ 总是优先执行较高优先级的工作（即在较高级队列中的工作）。当然，每个队列中可能会有多个工作，因此具有同样的优先级。在这种情况下，我们就对这些工作采用轮转调度。MLFQ在进程运行过程中学习其行为，从而利用工作的历史来预测它未来的行为。</p>
<p>MLFQ基本规则：<br>规则 1：如果 A 的优先级 &gt; B 的优先级，运行 A（不运行 B）。<br>规则 2：如果 A 的优先级 &#x3D; B 的优先级，轮转运行A 和 B。</p>
<p>MLFQ优化后规则：<br>规则 1：如果 A 的优先级 &gt; B 的优先级，运行 A（不运行 B）。<br>规则 2：如果 A 的优先级 &#x3D; B 的优先级，轮转运行 A 和 B。<br>规则 3：工作进入系统时，放在最高优先级（最上层队列）。<br>规则 4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级（移入低一级队列）。<br>规则 5：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。</p>
<p>通过这种方式，MLFQ 可以同时满足各种工作的需求：对于短时间运行的交互型工作，获得类似于 SJF&#x2F;STCF 的很好的全局性能，同时对长时间运行的CPU 密集型负载也可以公平地、不断地稳步向前。 </p>
<h3 id="调度：比例份额"><a href="#调度：比例份额" class="headerlink" title="调度：比例份额"></a>调度：比例份额</h3><p>比例份额算法基于一个简单的想法：调度程序的最终目标，是确保每个工作获得一定比例的 CPU 时间，而不是优化周转时间和响应时间。比例份额调度有一个非常优秀的现代例子，名为彩票调度：每隔一段时间，都会举行一次彩票抽奖，以确定接下来应该运行哪个进程。越是应该频繁运行的进程，越是应该拥有更多地赢得彩票的机会。</p>
<h4 id="基本概念：彩票数表示份额"><a href="#基本概念：彩票数表示份额" class="headerlink" title="基本概念：彩票数表示份额"></a>基本概念：彩票数表示份额</h4><p>彩票数代表了进程占有某个资源的份额，一个进程拥有的彩票数占总彩票数的百分比，就是它占有的资源的份额。<br>彩票调度最精彩的地方在于利用了随机性（randomness）。当你需要做出决定时，采用随机的方式常常是既可靠又简单的选择。随机方法相对于传统的决策方式，至少有3点优势。第一，随机方法常常可以避免奇怪的边角情况。第二，随机方法很轻量。第三，随机方法很快。</p>
<h4 id="彩票机制"><a href="#彩票机制" class="headerlink" title="彩票机制"></a>彩票机制</h4><p>彩票调度提供一些机制，以不同且有效的方式来调度彩票。<br>彩票货币：这种方式允许拥有一组彩票的用户以他们喜欢的某种货币，将彩票分给自己的不同工作。之后操作系统再自动将这种货币兑换为正确的全局彩票。<br>彩票转让：通过转让，一个进程可以临时将自己的彩票交给另一个进程。这种机制在客户端&#x2F;服务端交互的场景中尤其有用，在这种场景中，客户端进程向服务端发送消息，请求其按自己的需求执行工作，为了加速服务端的执行，客户端可以将自己的彩票转让给服务端，从而尽可能加速服务端执行自己请求的速度。服务端执行结束后会将这部分彩票归还给客户端。<br>彩票通胀：利用通胀，一个进程可以临时提升或降低自己拥有的彩票数量。在进程之间相互信任的环境下，如果一个进程知道它需要更多 CPU 时间，就可以增加自己的彩票，从而将自己的需求告知操作系统，这一切不需要与任何其他进程通信。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>彩票调度中最不可思议的，或许就是实现简单。只需要一个不错的随机数生成器来选择中奖彩票和一个记录系统中所有进程的数据结构（一个列表），以及所有彩票的总数。<br>只有当工作执行非常多的时间片时，彩票调度算法才能得到期望的结果。并且彩票调度中最难的票数分配问题没有确定解决方法。</p>
<h4 id="步长调度"><a href="#步长调度" class="headerlink" title="步长调度"></a>步长调度</h4><p>由于随机方式偶尔不能产生正确的比例，尤其在工作运行时间很短的情况下，因此诞生了步长调度，即<strong>系统中的每个工作都有自己的步长，这个值与票数值成反比</strong>。<br>比如A、B、C 这 3 个工作的票数分别是 100、50 和 250，我们通过用一个大数分别除以他们的票数来获得每个进程的步长。比如用 10000 除以这些票数值，得到了 3 个进程的步长分别为 100、200 和 40。我们称这个值为每个进程的步长（stride）。每次进程运行后，我们会让它的计数器 (称为行程（pass）值) 增加它的步长，记录它的总体进展。之后，调度程序使用进程的步长及行程值来确定调度哪个进程。基本思路很简单：当需要进行调度时，选择目前拥有最小行程值的进程，并且在运行之后将该进程的行程值增加一个步长。<br>但步长调度相较于彩票调度需要全局状态，如果在步长调度执行过程中，有新的进程加入系统，就难以设置它的行程值。</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo/20230502150309.png"></p>
<h2 id="六、分段"><a href="#六、分段" class="headerlink" title="六、分段"></a>六、分段</h2><h3 id="内外碎片之分"><a href="#内外碎片之分" class="headerlink" title="内外碎片之分"></a>内外碎片之分</h3><p>内部碎片：已经分配的内存单元内部有未使用的空间（即碎片），造成了浪费。<br>外部碎片：除了已分配的内存单元之外的空闲内存块（比如段和段之间存在外部碎片）。</p>
<h3 id="分段的机制"><a href="#分段的机制" class="headerlink" title="分段的机制"></a>分段的机制</h3><p>如果我们将整个地址空间放入物理内存，那么栈和堆之间的空间并没有被进程使用，却依然占用了实际的物理内存。因此，简单的通过基址寄存器和界限寄存器实现的虚拟内存很浪费。另外，如果剩余物理内存无法提供连续区域来放置完整的地址空间，进程便无法运行。</p>
<p>因此，在 MMU 中引入不止一个基址和界限寄存器对，而是给地址空间内的每个逻辑段（segment）一对。一个段只是地址空间里的一个连续定长的区域，在典型的地址空间里有 3 个逻辑不同的段：代码、栈和堆。分段的机制使得操作系统能够将不同的段放到不同的物理内存区域，从而避免了虚拟地址空间中的未使用部分占用物理内存。</p>
<h3 id="如何计算"><a href="#如何计算" class="headerlink" title="如何计算"></a>如何计算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ARG seed 0</span><br><span class="line">ARG address space size 128</span><br><span class="line">ARG phys mem size 512</span><br><span class="line"></span><br><span class="line">Segment register information:</span><br><span class="line"></span><br><span class="line">  Segment 0 base  (grows positive) : 0x00000000 (decimal 0)</span><br><span class="line">  Segment 0 limit                  : 20</span><br><span class="line"></span><br><span class="line">  Segment 1 base  (grows negative) : 0x00000200 (decimal 512)</span><br><span class="line">  Segment 1 limit                  : 20</span><br><span class="line"></span><br><span class="line">Virtual Address Trace</span><br><span class="line">  VA  0: 0x0000006c (decimal:  108) --&gt; VALID in SEG1: 0x000001ec (decimal:  492)</span><br><span class="line">  VA  1: 0x00000061 (decimal:   97) --&gt; SEGMENTATION VIOLATION (SEG1)</span><br><span class="line">  VA  2: 0x00000035 (decimal:   53) --&gt; SEGMENTATION VIOLATION (SEG0)</span><br><span class="line">  VA  3: 0x00000021 (decimal:   33) --&gt; SEGMENTATION VIOLATION (SEG0)</span><br><span class="line">  VA  4: 0x00000041 (decimal:   65) --&gt; SEGMENTATION VIOLATION (SEG1)</span><br></pre></td></tr></table></figure>

<p>如上述例子中，有两个段，一个段0一个段1。其中段0是正向增长，段1是反向增长的（栈）。对于VA0：0x0000006c即01101100，前两位为01，即在SEG1。对应的，如果前两位为00，即在SEG0，在不同的段对应不同的地址转换。对于VA0，由于其段是反向增长的，我们要得到正确的反向偏移，需要从108中减去最大的段地址128，即-20，反向偏移量(-20)加上基址(512)为492，在界限内。</p>
<h2 id="七、空闲空间管理"><a href="#七、空闲空间管理" class="headerlink" title="七、空闲空间管理"></a>七、空闲空间管理</h2><h3 id="四大匹配"><a href="#四大匹配" class="headerlink" title="四大匹配"></a>四大匹配</h3><p><strong>最优匹配</strong>：首先遍历整个空闲列表，找到和请求大小一样或更大的空闲块，然后返回这组候选者中最小的一块（需要全部遍历）。<br><strong>最差匹配</strong>：尝试找最大的空闲块，分割并满足用户需求后，将剩余的块（很大）加入空闲列表。最差匹配尝试在空闲列表中保留较大的块，而不是向最优匹配那样可能剩下很多难以利用的小块（需要全部遍历且开销很大）。<br><strong>首次匹配</strong>：找到第一个足够大的块，将请求的空间返回给用户。同样，剩余的空闲空间留给后续请求（不需要全部遍历，有速度优势，但要求空闲块基于地址排序）。<br><strong>下次匹配</strong>：不同于首次匹配每次都从列表的开始查找，下次匹配（next fit）算法多维护一个指针，指向上一次查找结束的位置。其想法是将对空闲空间的查找操作扩散到整个列表中去，避免对列表开头频繁的分割。这种策略的性能与首次匹配很接它，同样避免了遍历查找。</p>
<h3 id="分离空闲列表"><a href="#分离空闲列表" class="headerlink" title="分离空闲列表"></a>分离空闲列表</h3><p>如果某个应用程序经常申请一种（或几种）大小的内存空间，那就用一个独立的列表，只管理这样大小的对象。其他大小的请求都交给更通用的内存分配程序。优点是，通过拿出一部分内存专门满足某种大小的请求，碎片就不再是问题了。而且，由于没有复杂的列表查找过程，这种特定大小的内存分配和释放都很快。</p>
<h3 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h3><p>因为合并对分配程序很关键，所以人们设计了一些方法，让合并变得简单，一个好例子就是二分伙伴分配程序。在这种系统中，空闲空间首先从概念上被看成大小为 2^N 的大空间。当有一个内存分配请求时，空闲空间被递归地一分为二，直到刚好可以满足请求的大小（再一分为二就无法满足）。</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo/20230502151439.png"></p>
<p>伙伴系统的漂亮之处在于块被释放时。如果将这个 8KB 的块归还给空闲列表，分配程序会检查“伙伴” 8KB 是否空闲。如果是，就合二为一，变成 16KB 的块。然后会检查这个 16KB 块的伙伴是否空闲，如果是，就合并这两块。这个递归合并过程继续上溯，直到合并整个内存区域，或者某一个块的伙伴还没有被释放。</p>
<h2 id="八、分页"><a href="#八、分页" class="headerlink" title="八、分页"></a>八、分页</h2><p>分页不是将一个进程的地址空间分割成几个不同长度的逻辑段（即代码、堆、段），而是分割成固定大小的单元，每个单元称为一页。相应地，我们把物理内存看成是定长槽块的阵列，叫作页帧（page frame）。每个这样的页帧包含一个虚拟内存页。其优点在于：灵活性，不会假定堆和栈的增长方向，以及它们如何使用。简单性，空闲空间管理更加简单，从空闲列表找出空闲页即可，并且还不会生成外部碎片。</p>
<p>为了记录地址空间的每个虚拟页放在物理内存中的位置，操作系统通常为每个进程保存一个数据结构，称为页表（page table）。页表一般保存在PCB中，即进程控制块。页表中的每一项（页表项，PTE）内容如下：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo/20230502145840.png"></p>
<h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h3><p>为了转换（translate）该过程生成的虚拟地址，我们必须首先将它分成两个组件：虚拟页面号（virtual page number，VPN）和页内的偏移量（offset）。VPN长度取决于页的数目，VPO的长度取决于页的大小。</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo/20230502151508.png"></p>
<h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><p>由于我们要记录虚拟地址转换到物理地址的映射信息，而这些映射信息一般存储在物理内存中，所以在转换虚拟地址时，分页逻辑上需要一次额外的内存访问。每次指令获取、显式加载或保存，都要额外读一次内存以得到转换信息，这慢得无法接受。因此我们增加所谓的地址转换旁路缓冲存储器（translation-lookaside buffer，TLB），它就是频繁发生的虚拟到物理地址转换的硬件缓存。</p>
<p>对于每次内存访问，硬件先检查 TLB，看看其中是否有期望的转换映射，如果有，就完成转换（很快），不用访问页表（其中有全部的转换映射）。</p>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>当页表过于大时，会消耗过多的内存，因此我们需要想办法来解决这个问题。一种方法就是采用多级页表，就像树一样。首先，将页表分成页大小的单元。然后，如果整页的页表项（PTE）无效，就完全不分配该页的页表。为了追踪页表的页是否有效（以及如果有效，它在内存中的位置），使用了名为页目录（page directory）的新结构。页目录因此可以告诉你页表的页在哪里，或者页表的整个页不包含有效页。</p>
<h4 id="地址转换-1"><a href="#地址转换-1" class="headerlink" title="地址转换"></a>地址转换</h4><p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo/20230502151520.png"></p>
<p>由于加入了页目录，因此地址转换也要进行变化。<br>①从VPN中提取页目录索引（简称 PDIndex），从而计算出页目录项（PDE）的地址：<br>PDEAddr &#x3D; PageDirBase +（PDIndex×sizeof（PDE）<br>②如果PDE有效，我们还要通过页表索引（Page-Table Index，PTIndex），计算出页表项（PTE）的地址：<br>PTEAddr &#x3D; (PDE.PFN &lt;&lt; SHIFT) + (PTIndex * sizeof(PTE))</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo/20230502150540.png"></p>
<p>如图，假如现在有VA：0x3F80，即11 1111 1000 0000，提取有效信息：PDI：1111；PTI：1110；VPO：000000<br>于是由图可知PDEAddr&#x3D;101，随后查看101的PT，可知PTEAddr&#x3D;55。即PFN&#x3D;55（0x37），VPO&#x3D;000000（0x0），因此组合一下就是物理地址就是0000 1101 1100 0000。</p>
<h3 id="页替换"><a href="#页替换" class="headerlink" title="页替换"></a>页替换</h3><p>由于操作系统给用户态的应用程序提供了一个虚拟的“大容量”内存空间，而实际的物理内存空间又没有那么大。所以操作系统就就“瞒着”应用程序，只把应用程序中“常用”的数据和代码放在物理内存中，而不常用的数据和代码放在了硬盘这样的存储介质上。但当程序读取本应在内存中的数据时，发现其不在内存，会触发页访问异常，此时系统会把应用程序当前需要的数据或代码放到内存中来，然后重新执行应用程序产生异常的访存指令。如果此时内存已满，我们则需要把系统认为“不常用”的页换出到磁盘上去，以腾出内存空闲空间给应用程序所需的数据或代码，这便是页替换。</p>
<h4 id="最优替换"><a href="#最优替换" class="headerlink" title="最优替换"></a>最优替换</h4><p>最优替换策略即替换内存中在最远将来才会被访问到的页。遗憾的是，正如我们之前在开发调度策略时所看到的那样，未来的访问是无法知道的，你无法为通用操作系统实现最优策略。</p>
<h4 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h4><p>该算法总是淘汰最先进入内存的页，即选择在内存中驻留时间最久的页予以淘汰。但它无法确定页的重要性，那些常被访问的页，往往在内存中也停留得最久，结果它们因变“老”而不得不被置换出去。此外，FIFO在增加放置页的页帧的情况下，反而使页访问异常次数增多。</p>
<h4 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h4><p>在内存满的时候它随机选择一个页进行替换。随机具有类似于 FIFO 的属性。实现我来很简单，但是它在挑选替换哪个页时不够智能。</p>
<h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><p>为了提高后续的命中率，我们再次通过历史的访问情况作为参考，根据局部性原则，是程序倾向于频繁地访问某些代码（例如循环）和数据结构（例如循环访问的数组）。因此我们可以根据页最近的访问次数来决定是否替换，这就是LRU的核心思想。</p>
<h4 id="近似LRU（时钟页替换算法）"><a href="#近似LRU（时钟页替换算法）" class="headerlink" title="近似LRU（时钟页替换算法）"></a>近似LRU（时钟页替换算法）</h4><p>遗憾的是LRU的开销十分巨大，扫描所有页的时间字段只是为了找到最精确最少使用的页，这个代价太昂贵。因此我们考虑能不能实现近似LRU，获得预期效果的同时并且降低开销，而时钟页替换算法就是近似LRU的一种。</p>
<p>时钟页替换算法把各个页面组织成环形链表的形式，类似于一个钟的表面。然后把一个指针（简称当前指针）指向最老的那个页面，即最先进来的那个页面。我们除了要考虑访问情况，还要考虑修改情况，因为淘汰修改过的页面还需要写回硬盘，使得其置换代价大于未修改过的页面。因此我们为每一页的对应页表项内容中增加一位引用位和一位修改位，当该页被访问时，CPU中的MMU硬件将把访问位置“1”。当该页被“写”时，CPU中的MMU硬件将把修改位置“1”。我们以（引用位，修改位）来表示四种可能的情况：（0，0）表示最近未访问未修改，因此优先替换掉；（0，1）表示最近未访问，但是被修改，其次替换；然后是（0，1），最后是（1，1）。</p>
<h2 id="九、并发"><a href="#九、并发" class="headerlink" title="九、并发"></a>九、并发</h2><p>我们希望能最大化的利用CPU，但CPU运算速度和IO传输速度是不平衡的，CPU完成计算任务后IO在花很长时间传输数据，此时CPU是空闲状态的。因此我们提出进程的概念，希望这个进程在执行IO操作时，CPU能切换到另一个进程来执行任务，这样提高了CPU的利用率。但是切换进程是需要切换内存映射地址，这是不小的性能开销。因此我们又提出线程的概念，一个进程创建的所有线程，都是共享一个内存空间的，这样线程做任务切换成本就很低了。而<strong>并发</strong>就是基于线程提出的：当多个线程执行时，CPU将运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。</p>
<p>我们先来介绍一些名词：<br><strong>临界区（critical section）</strong> 是访问共享资源的一段代码，资源通常是一个变量或数据结构。</p>
<p><strong>竞态条件（race condition）</strong> 出现在多个执行线程大致同时进入临界区时，它们都试图更新共享的数据结构，导致了令人惊讶的（也许是不希望的）结果。</p>
<p><strong>不确定性（indeterminate）</strong> 程序由一个或多个竞态条件组成，程序的输出因运行而异，具体取决于哪些线程在何时运行。这导致结果不是确定的（deterministic），而我们通常期望计算机系统给出确定的结果。</p>
<p>为了避免这些问题，线程应该使用某种互斥（mutual exclusion）原语。这样做可以保证只有一个线程进入临界区，从而避免出现竞态，并产生确定的程序输出。</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>为了避免多个线程进入临界区同时修改共享的数据，我们提出锁这个概念，将锁放在临界区周围，保证临界区能够像单条原子指令一样执行，由于锁的存在，可以保证临界区内只有一个线程活跃。</p>
<p>对于锁，我们提出三个评价标准：<br><strong>互斥</strong>：这是锁的最基本任务，阻止多个线程同时进入临界区。<br><strong>公平性</strong>：每一个线程应该都有公平的机会抢到锁，不然会出现某一线程一直霸占锁不释放，导致与其竞争的线程被“饿死”。<br><strong>性能</strong>：具体来说，是使用锁之后增加的时间开销。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>此外，我们还要注意死锁的情况，即两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。如果在一个系统中以下四个条件同时成立，那么就能引起死锁：</p>
<p><strong>互斥</strong>：线程对于需要的资源进行互斥的访问（例如一个线程抢到锁）。<br><strong>持有并等待</strong>：线程持有了资源（例如已将持有的锁），同时又在等待其他资源（例如，需要获得的锁）。<br><strong>非抢占</strong>：线程获得的资源（例如锁），不能被抢占。<br><strong>循环等待</strong>：线程之间存在一个环路，环路上每个线程都额外持有一个资源，而这个资源又是下一个线程要申请的。</p>
<p>如果这4个条件的任何一个没有满足，死锁就不会产生。循环等待条件意味着持有并等待条件，这样四个条件并不完全独立。</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo/20230502151631.png"></p>
<p>预防死锁的方法：每个策略都设法阻止某一个条件，从而解决死锁的问题。<br>通过调度避免死锁：除了死锁预防，某些场景更适合死锁避免（avoidance）。我们需要了解全局的信息，包括不同线程在运行中对锁的需求情况，从而使得后续的调度能够避免产生死锁。避免死锁的方法有<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45934436/article/details/115859629">银行家算法</a>。<br>检查和恢复：最后一种常用的策略就是允许死锁偶尔发生，检查到死锁时再采取行动。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>自旋锁就是当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">int</span> new, <span class="type">int</span> mutex)</span> &#123; <span class="comment">//xchg指令（原子交换指令）的伪代码实现，避免中断的打断</span></span><br><span class="line"><span class="type">int</span> old = mutex; </span><br><span class="line">mutex = new; </span><br><span class="line"><span class="keyword">return</span> mutex; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">    lock(mutex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(TestAndSet(<span class="number">1</span>,mutex)==<span class="number">1</span>); <span class="comment">//自旋</span></span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">    unlock(mutex)</span><br><span class="line">    &#123;</span><br><span class="line">        mutex=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="休眠锁"><a href="#休眠锁" class="headerlink" title="休眠锁"></a>休眠锁</h4><p>可以看出来，简单的自旋锁无法保证多线程竞争的公平性，有可能有的线程一直抢不到锁，导致饿死。此外未得到锁的进程会一直自旋，浪费CPU资源。因此我们需要一个队列来保存等待锁的线程，并且让线程在获取不到锁时睡眠，在锁可用时被唤醒。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span> </span><br><span class="line">  <span class="type">int</span> flag; </span><br><span class="line">  <span class="type">int</span> guard; </span><br><span class="line">  <span class="type">queue_t</span> *q; </span><br><span class="line">&#125; <span class="type">lock_t</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_init</span><span class="params">(<span class="type">lock_t</span> *m)</span> &#123; </span><br><span class="line">  m-&gt;flag = <span class="number">0</span>; </span><br><span class="line">  m-&gt;guard = <span class="number">0</span>; </span><br><span class="line">  queue_init(m-&gt;q); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *m)</span> &#123; </span><br><span class="line"> <span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>); <span class="comment">//acquire guard lock by spinning </span></span><br><span class="line"> <span class="keyword">if</span> (m-&gt;flag == <span class="number">0</span>) &#123; </span><br><span class="line">     m-&gt;flag = <span class="number">1</span>; <span class="comment">// lock is acquired </span></span><br><span class="line">     m-&gt;guard = <span class="number">0</span>; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">     queue_add(m-&gt;q, gettid()); </span><br><span class="line">     m-&gt;guard = <span class="number">0</span>; </span><br><span class="line">     park(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *m)</span> &#123; </span><br><span class="line"> <span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>); <span class="comment">//acquire guard lock by spinning </span></span><br><span class="line"> <span class="keyword">if</span> (queue_empty(m-&gt;q)) </span><br><span class="line">     m-&gt;flag = <span class="number">0</span>; <span class="comment">// let go of lock; no one wants it </span></span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line">     unpark(queue_remove(m-&gt;q)); <span class="comment">// hold lock (for next thread!) </span></span><br><span class="line">     m-&gt;guard = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>锁并不是并发程序设计所需的唯一原语。具体来说，在很多情况下，线程需要检查某一条件（condition）满足之后，才会继续运行。例如，父线程需要检查子线程是否执行完毕。因此我们提出了条件变量这个概念。</p>
<p>条件变量是一个显式队列，当某些执行状态（即条件，condition）不满足时，线程可以把自己加入队列，等待（waiting）该条件。另外某个线程，当它改变了上述状态时，就可以唤醒一个或者多个等待线程（通过在该条件上发信号），让它们继续执行。</p>
<p>用消费者和生产者问题举例：假设有一个或多个生产者线程和一个或多个消费者线程。生产者把生成的数据项放入缓冲区；消费者从缓冲区取走数据项，以某种方式消费。因为有界缓冲区是共享资源，所以我们必须通过同步机制来访问它，以免产生竞态条件。所以我们可以使用条件变量和锁来解决这个问题，完整的代码如下：<br>put()和 get()方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> buffer[MAX]; </span><br><span class="line"><span class="type">int</span> fill = <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> use = <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> value)</span> &#123; </span><br><span class="line">  buffer[fill] = value; </span><br><span class="line">  fill = (fill + <span class="number">1</span>) % MAX; </span><br><span class="line">  count++; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123; </span><br><span class="line"> <span class="type">int</span> tmp = buffer[use]; </span><br><span class="line"> use = (use + <span class="number">1</span>) % MAX; </span><br><span class="line"> count--; </span><br><span class="line"> <span class="keyword">return</span> tmp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终方案</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">cond_t</span> empty, fill; </span><br><span class="line"><span class="type">mutex_t</span> mutex; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123; </span><br><span class="line">  <span class="type">int</span> i; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123; </span><br><span class="line">      Pthread_mutex_lock(&amp;mutex); <span class="comment">// p1 </span></span><br><span class="line">      <span class="keyword">while</span> (count == MAX) <span class="comment">// p2 </span></span><br><span class="line">      Pthread_cond_wait(&amp;empty, &amp;mutex); <span class="comment">// p3 </span></span><br><span class="line">     put(i); <span class="comment">// p4 </span></span><br><span class="line">     Pthread_cond_signal(&amp;fill); <span class="comment">// p5 </span></span><br><span class="line">     Pthread_mutex_unlock(&amp;mutex); <span class="comment">// p6 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123; </span><br><span class="line"> <span class="type">int</span> i; </span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123; </span><br><span class="line">     Pthread_mutex_lock(&amp;mutex); <span class="comment">// c1 </span></span><br><span class="line">     <span class="keyword">while</span> (count == <span class="number">0</span>) <span class="comment">// c2 </span></span><br><span class="line">     Pthread_cond_wait(&amp;fill, &amp;mutex); <span class="comment">// c3 </span></span><br><span class="line">     <span class="type">int</span> tmp = get(); <span class="comment">// c4 </span></span><br><span class="line">     Pthread_cond_signal(&amp;empty); <span class="comment">// c5 </span></span><br><span class="line">     Pthread_mutex_unlock(&amp;mutex); <span class="comment">// c6 </span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是一种同步互斥机制的实现，普遍存在于现在的各种操作系统内核里，即我们可以用信号量来实现锁和条件变量。对于信号量，它是有一个整数值的对象，有两个关键函数对其进行操作， POSIX 标准中，是sem_wait()和 sem_post()，即P操作和V操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span> </span></span><br><span class="line"><span class="type">sem_t</span> s; <span class="comment">//信号量</span></span><br><span class="line">sem_init(&amp;s, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">//初始化信号量为1，第二个参数指信号量是在同一进程的多个线程共享的，第三个参数指将信号量初始化为1</span></span><br></pre></td></tr></table></figure>

<p>对于sem_wait()函数，先判断信号量是否&gt;0，如果是，它会将信号量减1。如果不是，那么该线程会进入睡眠等待（即最终信号量&lt;0，调用该函数的线程就会进入睡眠）。<br>对于sem_post()函数，它会直接将信号量加1，如果此时信号量&gt;0，那么它会唤醒等待队列中第一个正在睡眠的线程。</p>
<p>因此我们可以利用信号量来解决生产者消费者问题（注意锁要紧挨着临界区）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sem_t</span> empty; </span><br><span class="line"><span class="type">sem_t</span> full; </span><br><span class="line"><span class="type">sem_t</span> mutex; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123; </span><br><span class="line">  <span class="type">int</span> i; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123; </span><br><span class="line">      sem_wait(&amp;empty); <span class="comment">// line p1 </span></span><br><span class="line">      sem_wait(&amp;mutex); <span class="comment">// line p1.5 (MOVED MUTEX HERE...) </span></span><br><span class="line">      put(i); <span class="comment">// line p2 </span></span><br><span class="line">      sem_post(&amp;mutex); <span class="comment">// line p2.5 (... AND HERE) </span></span><br><span class="line">     sem_post(&amp;full); <span class="comment">// line p3 </span></span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123; </span><br><span class="line"> <span class="type">int</span> i; </span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123; </span><br><span class="line">     sem_wait(&amp;full); <span class="comment">// line c1 </span></span><br><span class="line">     sem_wait(&amp;mutex); <span class="comment">// line c1.5 (MOVED MUTEX HERE...) </span></span><br><span class="line">     <span class="type">int</span> tmp = get(); <span class="comment">// line c2 </span></span><br><span class="line">     sem_post(&amp;mutex); <span class="comment">// line c2.5 (... AND HERE) </span></span><br><span class="line">     sem_post(&amp;empty); <span class="comment">// line c3 </span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123; </span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line">sem_init(&amp;empty, <span class="number">0</span>, MAX); <span class="comment">// MAX buffers are empty to begin with... </span></span><br><span class="line">sem_init(&amp;full, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// ... and 0 are full </span></span><br><span class="line">sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// mutex=1 because it is a lock </span></span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读者写者锁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">rwlock_t</span> &#123;</span> </span><br><span class="line">  <span class="type">sem_t</span> lock; <span class="comment">// binary semaphore (basic lock) </span></span><br><span class="line">  <span class="type">sem_t</span> writelock; <span class="comment">// used to allow ONE writer or MANY readers </span></span><br><span class="line">  <span class="type">int</span> readers; <span class="comment">// count of readers reading in critical section </span></span><br><span class="line">&#125; <span class="type">rwlock_t</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_init</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123; </span><br><span class="line">  rw-&gt;readers = <span class="number">0</span>; </span><br><span class="line">  sem_init(&amp;rw-&gt;lock, <span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line">  sem_init(&amp;rw-&gt;writelock, <span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123; </span><br><span class="line"> sem_wait(&amp;rw-&gt;lock); </span><br><span class="line"> rw-&gt;readers++; </span><br><span class="line"> <span class="keyword">if</span> (rw-&gt;readers == <span class="number">1</span>) </span><br><span class="line">    sem_wait(&amp;rw-&gt;writelock); <span class="comment">// first reader acquires writelock </span></span><br><span class="line"> sem_post(&amp;rw-&gt;lock); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123; </span><br><span class="line"> sem_wait(&amp;rw-&gt;lock); </span><br><span class="line"> rw-&gt;readers--; </span><br><span class="line"> <span class="keyword">if</span> (rw-&gt;readers == <span class="number">0</span>) </span><br><span class="line">    sem_post(&amp;rw-&gt;writelock); <span class="comment">// last reader releases writelock </span></span><br><span class="line"> sem_post(&amp;rw-&gt;lock); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123; </span><br><span class="line"> sem_wait(&amp;rw-&gt;writelock); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123; </span><br><span class="line"> sem_post(&amp;rw-&gt;writelock); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哲学家就餐问题：<br>我们先来看哲学家就餐的主要代码，即思考，拿起叉子，进餐，放下叉子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> state_sema[N]; <span class="comment">/* 记录每个人状态的数组 */</span></span><br><span class="line"><span class="comment">/* 信号量是一个特殊的整型变量 */</span></span><br><span class="line"><span class="type">semaphore_t</span> mutex; <span class="comment">/* 临界区互斥 */</span></span><br><span class="line"><span class="type">semaphore_t</span> s[N]; <span class="comment">/* 每个哲学家一个信号量 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">philosopher_proc_sema</span>[<span class="title">N</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">philosopher_using_semaphore</span><span class="params">(<span class="type">void</span> * arg)</span> <span class="comment">/* i：哲学家号码，从0到N-1 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, iter=<span class="number">0</span>;</span><br><span class="line">    i=(<span class="type">int</span>)arg;</span><br><span class="line">    cprintf(<span class="string">&quot;I am No.%d philosopher_sema\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">while</span>(iter++&lt;TIMES)</span><br><span class="line">    &#123; <span class="comment">/* 无限循环 */</span></span><br><span class="line">        cprintf(<span class="string">&quot;Iter %d, No.%d philosopher_sema is thinking\n&quot;</span>,iter,i); <span class="comment">/* 哲学家正在思考 */</span></span><br><span class="line">        do_sleep(SLEEP_TIME);  <span class="comment">//在SLEEP_TIME这段时间内，当前进程放弃CPU资源</span></span><br><span class="line">        phi_take_forks_sema(i); </span><br><span class="line">        <span class="comment">/* 需要两只叉子，或者阻塞 */</span></span><br><span class="line">        cprintf(<span class="string">&quot;Iter %d, No.%d philosopher_sema is eating\n&quot;</span>,iter,i); <span class="comment">/* 进餐 */</span></span><br><span class="line">        do_sleep(SLEEP_TIME);</span><br><span class="line">        phi_put_forks_sema(i); </span><br><span class="line">        <span class="comment">/* 把两把叉子同时放回桌子 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    cprintf(<span class="string">&quot;No.%d philosopher_sema quit\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿起 &#x2F; 放下叉子时，由于需要修改当前哲学家的状态，同时该状态是全局共享变量，所以需要上锁来防止条件竞争。将叉子放回桌上时，如果当前哲学家左右两边的两位哲学家处于饥饿状态，即准备进餐但没有刀叉时，如果条件符合（有两个空闲叉子），则唤醒这两位哲学家并让其继续进餐。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">phi_take_forks_sema</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">/* i：哲学家号码从0到N-1 */</span></span><br><span class="line">&#123; </span><br><span class="line">        down(&amp;mutex); <span class="comment">/* 进入临界区 */</span></span><br><span class="line">        state_sema[i]=HUNGRY; <span class="comment">/* 记录下哲学家i饥饿的事实 */</span></span><br><span class="line">        phi_test_sema(i); <span class="comment">/* 试图得到两只叉子 */</span></span><br><span class="line">        up(&amp;mutex); <span class="comment">/* 离开临界区 */</span></span><br><span class="line">        down(&amp;s[i]); <span class="comment">/* 如果得不到叉子就阻塞 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">phi_put_forks_sema</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">/* i：哲学家号码从0到N-1 */</span></span><br><span class="line">&#123; </span><br><span class="line">        down(&amp;mutex); <span class="comment">/* 进入临界区 */</span></span><br><span class="line">        state_sema[i]=THINKING; <span class="comment">/* 哲学家进餐结束 */</span></span><br><span class="line">        phi_test_sema(LEFT); <span class="comment">/* 看一下左邻居现在是否能进餐 */</span></span><br><span class="line">        phi_test_sema(RIGHT); <span class="comment">/* 看一下右邻居现在是否能进餐 */</span></span><br><span class="line">        up(&amp;mutex); <span class="comment">/* 离开临界区 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>phi_test_sema函数用于设置哲学家的进食状态。如果当前哲学家满足进食条件，则更新哲学家状态，执行哲学家锁所对应的V操作，以唤醒等待叉子的哲学家所对应的线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">phi_test_sema</span><span class="params">(i)</span> <span class="comment">/* i：哲学家号码从0到N-1 */</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span>(state_sema[i]==HUNGRY&amp;&amp;state_sema[LEFT]!=EATING</span><br><span class="line">            &amp;&amp;state_sema[RIGHT]!=EATING)</span><br><span class="line">    &#123;</span><br><span class="line">        state_sema[i]=EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十、持久性化"><a href="#十、持久性化" class="headerlink" title="十、持久性化"></a>十、持久性化</h2><h3 id="磁盘驱动器"><a href="#磁盘驱动器" class="headerlink" title="磁盘驱动器"></a>磁盘驱动器</h3><p>磁盘如图所示：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo/20230502151703.png"></p>
<h4 id="IO时间计算"><a href="#IO时间计算" class="headerlink" title="IO时间计算"></a>IO时间计算</h4><p>IO时间：$T_{IO}&#x3D;T_{寻道}+T_{旋转}+T_{传输}$<br>IO速率：$R_{IO}&#x3D;传输大小&#x2F;T_{IO}$</p>
<p>通过一个例子来理解IO时间如何计算，如图为磁盘初始状态：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo/20230502152121.png"></p>
<p>假如现在有以下访问请求（访问扇区30，此处暂且不讨论多个扇区访问的请求）：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo/20230502152156.png">（顺时针旋转）现假定单位寻道时间为40，旋转1度旋转时间为1，一个扇区占30度，传输在扇区之间开始和结束。因此，要读取第10扇区，传输从9和10之间的一半开始，在10和11之间的一半结束，因此传输时间为30。则对于以上例子：<br>寻道时间：80（跨越两个磁道）<br>旋转时间：如果不用寻道，30和6在初始态是同一位置，意味着旋转到最后磁头要在6和5之间（这样才能完整读取6这个扇区），则旋转时间为360-15&#x3D;345。由于存在寻道，因此寻道的过程中同时也在旋转，最后的旋转时间为345-80&#x3D;265。（如果没有寻道，旋转时间小于寻道时间，比如45&lt;80，那么找到对应磁道的时候，对应扇区旋转过去了，需要额外等待。则旋转时间为360-（80-45）&#x3D;345）<br>传输时间：固定为30<br>总时间：80+265+30&#x3D;375</p>
<p>理解磁道偏斜：</p>
<p>由上述例子不难看出，从一个磁道切换到另一个磁道时，磁盘需要时间来重新定位磁头，有可能此时要读取的扇区刚好错过，这时需要重新等待磁盘旋转一圈才能读取。因此我们引入了磁道偏斜：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo/20230502152210.png"><br>左为磁盘没有偏斜，右为磁盘偏斜为1，可以看出，相比没有磁道偏斜的情况，当磁道偏斜为1时，内侧磁道将相对于其外侧的那个磁道进行一个扇区的偏斜，因此最里面的磁道和最外面的磁道偏斜为2。<br>寻道时间为S，旋转角速度为W，一个扇区跨越的角度为A，偏斜为O，计算偏斜的公式可为：<br>S &lt; A * O &#x2F; W ， 即 O &gt; S * W &#x2F; A，O取最小整数即可。</p>
<h4 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h4><p>当有多个扇区访问请求时，我们需要合理的规划访问计划，使得IO时间尽可能短。</p>
<p><strong>FCFS（FIFO）</strong>：先来先服务。 <strong>SSTF</strong>：最短寻道时间优先，SSTF 按磁道对 I&#x2F;O 请求队列排序，选择在最近磁道上的请求先完成。但其有个致命缺点，也就是容易造成饥饿，如果有磁头当前所在位置的内圈磁道有稳定的请求，那么纯粹的 SSTF 方法将完全忽略对其他磁道的请求。</p>
<p> <strong>电梯（又称 SCAN 或 C-SCAN）</strong>：针对上述的饥饿现象，我们提出了新的SCAN调度策略，简单地以跨越磁道的顺序来服务磁盘请求。我们将一次跨越磁盘称为扫一遍。因此，如果请求的块所属的磁道在这次扫一遍中已经服务过了，它就不会立即处理，而是排队等待下次扫一遍。而C-SCAN是其常见变体，它不是在一个方向扫过磁盘，该算法从外圈扫到内圈，然后从内圈扫到外圈，如此下去。其缺点在于，忽视了旋转时间。</p>
<p> <strong>SPTF（也称SATF）</strong>：最短定位时间优先，其执行过程中总是视情况而定，以最短定位时间为优先原则（寻道时间和旋转时间相比较），当在同一磁道的旋转时间太长，大于先去其它磁道读取再回来的时间，此时SPTF优先读取其他磁道的扇区，相反如果寻道时间远大于旋转时间，那么SPTF等价于SSTF。</p>
<h3 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h3><p>RAID即廉价冗余磁盘阵列，使用多个磁盘一起构建更快、更大、更可靠的磁盘系统。RAID有4个重要的级别：</p>
<p><strong>RAID-0</strong>：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo/20230502152442.png"></p>
<p><strong>RAID-1</strong>：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo/20230502152457.png"></p>
<p><strong>RAID-4</strong>：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo/20230502152511.png"></p>
<p><strong>RAID-5</strong> </p>
<p>RAID-4的小写入问题：当我们同时往RAID-4写入写入块4和块13。这些磁盘的数据位于磁盘0和1上，因此对数据的读写操作可以并行进行，但出现的问题是奇偶校验磁盘。这两个请求都必须读取4和13的奇偶校验块，即奇偶校验块1和3（用+标记）。在这种类型的工作负载下，奇偶校验磁盘是瓶颈，因为你无法同时在disk4上读取两个扇区。此外RAID-4每次逻辑上的写入，都需要执行读和写两个操作，读是读取旧数据与新数据比较，看看是否要更改奇偶校验位，如果要那么就要进行更改，这使得随机小写入吞吐量很差。</p>
<p>在此基础上发展出RAID-5，RAID-5有四种分布形式： <img src="http://zohead.com/wp-content/uploads/raid5-layouts.jpg" alt="四种分布"> “左”、“右”表示校验和（也就是图中的P）如何分布，“左”的校验和都是从最后一个磁盘开始，依次前推，“右”的校验和从第一个磁盘开始，依次后推。“不对称”分布方式都是直接将数据按照磁盘的数据直接排下来的，而“对称”方式则将每个条带中的第一个数据放在校验和的后面，然后往后排列，需要时再绕回第一个磁盘，这样“对称”的数据排列方式就能始终按照磁盘的顺序依次下来。由于每个条带的奇偶校验块现在都在磁盘上旋转，以此来消除 RAID-4 的奇偶校验磁盘瓶颈。</p>
<p>其中S为单个磁盘顺序带宽（在连续工作负载下以 S MB&#x2F;s 传输数据），R为单个磁盘随机带宽，N为磁盘数，T 为对单个磁盘的请求所需的时间。</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo/20230502152544.png"></p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo/20230502152552.png"></p>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo/20230502152603.png"></p>
<p>文件系统在磁盘上的数据结构的整体组织：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo/20230502152625.png"></p>
<p>这是一个只有64块大小的磁盘，每个块4KB大。</p>
<p> <strong>S是超级块</strong>（SuperBlock），它主要从文件系统的全局角度描述特定文件系统的全局信息，例如文件系统中有多少个inode和数据块（在这个例子中分别为 80 和 56）、inode表的开始位置（块 3）等等。</p>
<p> <strong>i和d是inode和data的位图（bitmap）</strong>，位图是一种简单的结构：每个位用于指示相应的对象&#x2F;块是空闲（0）还是正在使用（1），这样就能记录inode和数据块是空闲还是已分配。 </p>
<p><strong>I是索引节点（inode）</strong>，每个inode中实际上是所有关于文件的信息：文件类型（例如，常规文件、目录等）、大小、分配给它的块数、保护信息（如谁拥有该文件以及谁可以访问它）、一些时间信息（包括文件创建、修改或上次访问的时间文件下），以及有关其数据块驻留在磁盘上的位置的信息（如某种类型的指针）。实际上，文件系统中除了纯粹的用户数据外，其他任何信息通常都称为元数据。 </p>
<p><strong>D是数据块</strong>，即用户存放的数据。</p>
<h4 id="多级索引"><a href="#多级索引" class="headerlink" title="多级索引"></a>多级索引</h4><p>为了支持更大的文件，文件系统设计者必须在 inode 中引入不同的结构。一个常见的思路是有一个称为间接指针（indirect pointer）的特殊指针。它不是指向包含用户数据的块，而是指向包含更多指针的块，每个指针指向用户数据。因此，inode 可以有一些固定数量（例如 12 个）的直接指针和一个间接指针。如果文件变得足够大，则会分配一个间接块（来自磁盘的数据块区域），并将 inode 的间接指针设置为指向它。<br>假如数据块大小为4KB，每个指针大小为4B。现在有一个直接指针，一个一级间接指针，一个二级间接指针，请问可寻址的文件大小是多少？<br>一个直接指针：1<em>4KB&#x3D;4KB<br>一个一级间接指针：（4KB&#x2F;4B）</em>4KB&#x3D;4MB<br>一个二级间接指针：1024 * 1024 * 4KB&#x3D;4GB</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://yeyuhl.github.io">夜语</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yeyuhl.github.io/2023/05/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">https://yeyuhl.github.io/2023/05/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yeyuhl.github.io" target="_blank">随便写写</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/%E7%89%B9%E5%AE%9A%E6%96%87%E4%BB%B6/1a14e4eeedd428147c921881097b3aed8a932201.jpg%40942w_942h_progressive.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="计算机网络期末复习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机网络期末复习</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/%E7%89%B9%E5%AE%9A%E6%96%87%E4%BB%B6/1a14e4eeedd428147c921881097b3aed8a932201.jpg%40942w_942h_progressive.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">夜语</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yeyuhl"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">随便写写的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0"><span class="toc-text">操作系统导论期末复习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D"><span class="toc-text">一、操作系统介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%99%9A%E6%8B%9F%E5%8C%96CPU"><span class="toc-text">1.虚拟化CPU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%99%9A%E6%8B%9F%E5%8C%96%E5%86%85%E5%AD%98"><span class="toc-text">2.虚拟化内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B9%B6%E5%8F%91"><span class="toc-text">3.并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8C%81%E4%B9%85%E6%80%A7"><span class="toc-text">4.持久性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%8A%BD%E8%B1%A1%EF%BC%9A%E8%BF%9B%E7%A8%8B"><span class="toc-text">二、抽象：进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-text">1.进程创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-text">2.进程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">3.数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%8F%92%E5%8F%99%EF%BC%9A%E8%BF%9B%E7%A8%8BAPI"><span class="toc-text">三、插叙：进程API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fork"><span class="toc-text">fork()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait"><span class="toc-text">wait()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exec"><span class="toc-text">exec()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%8F%97%E9%99%90%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C"><span class="toc-text">四、机制：受限直接执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-1%EF%BC%9A%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">问题 1：受限制的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-2%EF%BC%9A%E5%9C%A8%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%88%87%E6%8D%A2"><span class="toc-text">问题 2：在进程之间切换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E4%BD%9C%E6%96%B9%E5%BC%8F%EF%BC%9A%E7%AD%89%E5%BE%85%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">协作方式：等待系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%8D%8F%E4%BD%9C%E6%96%B9%E5%BC%8F%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E8%A1%8C%E6%8E%A7%E5%88%B6"><span class="toc-text">非协作方式：操作系统进行控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E5%92%8C%E6%81%A2%E5%A4%8D%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">保存和恢复上下文</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%9A%E4%BB%8B%E7%BB%8D"><span class="toc-text">五、进程调度：介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD%E5%81%87%E8%AE%BE"><span class="toc-text">工作负载假设</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E6%8C%87%E6%A0%87"><span class="toc-text">调度指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-text">四种调度策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E5%90%88I-x2F-O"><span class="toc-text">结合I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%EF%BC%9A%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97"><span class="toc-text">调度：多级反馈队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%EF%BC%9A%E6%AF%94%E4%BE%8B%E4%BB%BD%E9%A2%9D"><span class="toc-text">调度：比例份额</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A%E5%BD%A9%E7%A5%A8%E6%95%B0%E8%A1%A8%E7%A4%BA%E4%BB%BD%E9%A2%9D"><span class="toc-text">基本概念：彩票数表示份额</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%A9%E7%A5%A8%E6%9C%BA%E5%88%B6"><span class="toc-text">彩票机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%95%BF%E8%B0%83%E5%BA%A6"><span class="toc-text">步长调度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%88%86%E6%AE%B5"><span class="toc-text">六、分段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%A4%96%E7%A2%8E%E7%89%87%E4%B9%8B%E5%88%86"><span class="toc-text">内外碎片之分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-text">分段的机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97"><span class="toc-text">如何计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-text">七、空闲空间管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%A4%A7%E5%8C%B9%E9%85%8D"><span class="toc-text">四大匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8"><span class="toc-text">分离空闲列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F"><span class="toc-text">伙伴系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%88%86%E9%A1%B5"><span class="toc-text">八、分页</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-text">地址转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLB"><span class="toc-text">TLB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-text">多级页表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-1"><span class="toc-text">地址转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E6%9B%BF%E6%8D%A2"><span class="toc-text">页替换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E6%9B%BF%E6%8D%A2"><span class="toc-text">最优替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FIFO"><span class="toc-text">FIFO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA"><span class="toc-text">随机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LRU"><span class="toc-text">LRU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%91%E4%BC%BCLRU%EF%BC%88%E6%97%B6%E9%92%9F%E9%A1%B5%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-text">近似LRU（时钟页替换算法）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%B9%B6%E5%8F%91"><span class="toc-text">九、并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81"><span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-text">自旋锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%91%E7%9C%A0%E9%94%81"><span class="toc-text">休眠锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-text">条件变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">信号量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E6%8C%81%E4%B9%85%E6%80%A7%E5%8C%96"><span class="toc-text">十、持久性化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E9%A9%B1%E5%8A%A8%E5%99%A8"><span class="toc-text">磁盘驱动器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97"><span class="toc-text">IO时间计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6"><span class="toc-text">磁盘调度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAID"><span class="toc-text">RAID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-text">多级索引</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/13/SimpleDB/" title="SimpleDB">SimpleDB</a><time datetime="2023-09-13T08:16:35.000Z" title="发表于 2023-09-13 16:16:35">2023-09-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/13/RaftKV/" title="RaftKV">RaftKV</a><time datetime="2023-09-13T08:14:29.000Z" title="发表于 2023-09-13 16:14:29">2023-09-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="人工智能期末复习">人工智能期末复习</a><time datetime="2023-06-03T15:39:19.000Z" title="发表于 2023-06-03 23:39:19">2023-06-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="数据库系统期末复习">数据库系统期末复习</a><time datetime="2023-05-14T08:32:30.000Z" title="发表于 2023-05-14 16:32:30">2023-05-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/12/Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="Java基础常见问题">Java基础常见问题</a><time datetime="2023-05-12T07:40:22.000Z" title="发表于 2023-05-12 15:40:22">2023-05-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 夜语</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>