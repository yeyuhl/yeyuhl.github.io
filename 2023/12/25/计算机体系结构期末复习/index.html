<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计算机体系结构期末复习 | 随便写写</title><meta name="author" content="夜语"><meta name="copyright" content="夜语"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 量化设计与分析基础1.5 能耗(Energy)与功率(Power)对于CMOS芯片来说，传统的主要能耗源是开关晶体管，也就是动态能耗，其能耗为：  而每个晶体管所需要的功率就是一次转换的能耗与转换频率的乘积：  因此降低时钟频率只能降低功耗，但是降低电压可以大幅降低动态功率和能耗。 1.6 芯片成本所谓芯片，需要在晶圆(wafer)上切割成晶片(die)进行封装，因此芯片成本和晶圆、晶片的成">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机体系结构期末复习">
<meta property="og:url" content="https://yeyuhl.github.io/2023/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="随便写写">
<meta property="og:description" content="1. 量化设计与分析基础1.5 能耗(Energy)与功率(Power)对于CMOS芯片来说，传统的主要能耗源是开关晶体管，也就是动态能耗，其能耗为：  而每个晶体管所需要的功率就是一次转换的能耗与转换频率的乘积：  因此降低时钟频率只能降低功耗，但是降低电压可以大幅降低动态功率和能耗。 1.6 芯片成本所谓芯片，需要在晶圆(wafer)上切割成晶片(die)进行封装，因此芯片成本和晶圆、晶片的成">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/%E7%89%B9%E5%AE%9A%E6%96%87%E4%BB%B6/1a14e4eeedd428147c921881097b3aed8a932201.jpg%40942w_942h_progressive.webp">
<meta property="article:published_time" content="2023-12-25T08:52:19.000Z">
<meta property="article:modified_time" content="2023-12-25T08:53:52.180Z">
<meta property="article:author" content="夜语">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/%E7%89%B9%E5%AE%9A%E6%96%87%E4%BB%B6/1a14e4eeedd428147c921881097b3aed8a932201.jpg%40942w_942h_progressive.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yeyuhl.github.io/2023/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机体系结构期末复习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-25 16:53:52'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/%E7%89%B9%E5%AE%9A%E6%96%87%E4%BB%B6/1a14e4eeedd428147c921881097b3aed8a932201.jpg%40942w_942h_progressive.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/%E7%89%B9%E5%AE%9A%E6%96%87%E4%BB%B6/wallhaven-p9woe3.png')"><nav id="nav"><span id="blog-info"><a href="/" title="随便写写"><span class="site-name">随便写写</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机体系结构期末复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-25T08:52:19.000Z" title="发表于 2023-12-25 16:52:19">2023-12-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-25T08:53:52.180Z" title="更新于 2023-12-25 16:53:52">2023-12-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E6%80%BB%E5%A4%8D%E4%B9%A0/">课程总复习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计算机体系结构期末复习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-量化设计与分析基础"><a href="#1-量化设计与分析基础" class="headerlink" title="1. 量化设计与分析基础"></a>1. 量化设计与分析基础</h1><h2 id="1-5-能耗-Energy-与功率-Power"><a href="#1-5-能耗-Energy-与功率-Power" class="headerlink" title="1.5 能耗(Energy)与功率(Power)"></a>1.5 能耗(Energy)与功率(Power)</h2><p>对于CMOS芯片来说，传统的主要能耗源是开关晶体管，也就是动态能耗，其能耗为： <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164214.png"></p>
<p>而每个晶体管所需要的功率就是一次转换的能耗与转换频率的乘积： <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164225.png"></p>
<p>因此降低时钟频率只能降低功耗，但是降低电压可以大幅降低动态功率和能耗。</p>
<h2 id="1-6-芯片成本"><a href="#1-6-芯片成本" class="headerlink" title="1.6 芯片成本"></a>1.6 芯片成本</h2><p>所谓芯片，需要在晶圆(wafer)上切割成晶片(die)进行封装，因此芯片成本和晶圆、晶片的成本息息相关。 <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164233.png"></p>
<p>而每个晶圆上的晶片数目大约等于晶圆面积&#x2F;晶片面积，更准确的估算公式为（注意是 (晶圆直径&#x2F;2)^2 ）： <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164240.png"></p>
<p>此外我们还需要知道晶片的成品率多少，因为成品率决定了有多少晶片是可以使用的。我们假设一种简单模型，假定晶圆上的缺陷随机分布，成品率与制造工艺复杂度成反比，那么可得： <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164248.png"></p>
<p>其中N是一个称之为工艺复杂度因数的参数，用于衡量制造难度，对于28nm工艺，N的大概范围是7.5-9.5。此外在书中的各种题目中，为了简单起见，<strong>一般假定晶圆成品率为100%（即1）</strong>。即： <strong>晶片正品率&#x3D;1&#x2F;(1+单位面积上的缺陷 * 晶片面积)^N</strong></p>
<h2 id="1-7-可信任度"><a href="#1-7-可信任度" class="headerlink" title="1.7 可信任度"></a>1.7 可信任度</h2><ul>
<li>**平均无故障时间(MTTF)**：是一种可靠性度量，MTTF的倒数就是故障率，通常以运行10亿小时发生的故障数来表示，或称为(FIT)。</li>
<li>**平均修复时间(MTTR)**：服务中断以MTTR来度量。</li>
<li>**平均故障间隔时间(MTBF)**：就是MTTF+MTTR。</li>
</ul>
<p><strong>模块可用性</strong>就是指在服务完成与服务中断两种状态之间切换时，对服务完成的度量。对于可修复的非冗余系统，模块可用性为： <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164303.png"></p>
<h2 id="1-9-计算机设计的量化原理"><a href="#1-9-计算机设计的量化原理" class="headerlink" title="1.9 计算机设计的量化原理"></a>1.9 计算机设计的量化原理</h2><h3 id="1-9-1-三大设计原则"><a href="#1-9-1-三大设计原则" class="headerlink" title="1.9.1 三大设计原则"></a>1.9.1 三大设计原则</h3><ul>
<li><strong>充分利用并行</strong>：<strong>系统级别开发并行</strong>，可以使用多个处理器和多个磁盘，然后在处理器和磁盘之间分散处理请求的工作负载，从而提高吞吐量。<strong>在单独处理器级别</strong>，通过流水线充分利用指令间的并行。在<strong>具体的数字设计级别</strong>也可以开发并行，比如说现代ALU使用先行进位，用并行来加快求和过程，亦或者程序中的循环展开。</li>
<li><strong>局域性原理</strong>：程序常常重复使用它们最近用过的数据和指令。时间局域性是指最近访问过的内容很可能会在短期内被再次访问。空间局域性是指地址相互临近的项目很可能会在短时间内都被用到。</li>
<li><strong>重点关注常见情形</strong>：最重要、最普遍的计算机设计原则。如果某一情形会频繁出现，那么针对其进行改进会产生更显著的效果。比如在处理器中对两个数值求和，可以预料到溢出是很少出现的情形，可以通过优化没有溢出的更常见情形来提高性能。有一种基本定律可以用来量化这一原则，即<strong>Amdahl定律</strong>。</li>
</ul>
<h3 id="1-9-2-Amdahl定律"><a href="#1-9-2-Amdahl定律" class="headerlink" title="1.9.2 Amdahl定律"></a>1.9.2 Amdahl定律</h3><p>原计算机采用升级模式后的执行时间等于该计算机未升级部分耗用的时间加上使用升级部分耗用的时间： <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164315.png"></p>
<p><strong>总加速比</strong>是这两个执行时间之比： <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164323.png"></p>
<p>重点关注课后习题12，求得总加速比后，问加速部分占新的执行时间的多少，其计算公式如下：</p>
<p><strong>（升级比例&#x2F;升级加速比）&#x2F;（1-升级比例+升级比例&#x2F;升级加速比）</strong></p>
<h3 id="1-9-3-处理器性能公式"><a href="#1-9-3-处理器性能公式" class="headerlink" title="1.9.3 处理器性能公式"></a>1.9.3 处理器性能公式</h3><p>计算机设计人员用时钟周期的持续时间（如1ns）或其频率（如1GHz）来描述时钟周期的时间。程序的CPU时间可以有两种表示方法： <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164335.png"> <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164344.png"></p>
<p>此外，除了执行一个程序所需要的时钟周期之外，我们还会计算所执行的指令数：<strong>指令路径长度或指令数</strong>（IC）。如果知道时钟周期数和指令数，就可以计算<strong>每条指令时钟周期数</strong>（CPI）的平均值，其倒数就是每时钟周期指令数（IPC）。 <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164351.png"></p>
<p>处理器的性能取决于三个特性：<strong>时钟周期</strong>、<strong>每条指令的时钟周期</strong>和<strong>指令数</strong>。其中时钟周期时间是硬件技术与组成（<strong>硬件</strong>），CPI是组成与指令集体系结构（<strong>ISA</strong>），指令数是指令集体系结构和编译器技术（<strong>ISA和软件</strong>）。这三者互相关联，想要在不改变其他两个参数的情况下对其中一个参数进行优化十分困难。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164508.png"></p>
<hr>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164519.png"></p>
<hr>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164526.png"></p>
<hr>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164535.png"></p>
<h1 id="3-指令级并行及其开发"><a href="#3-指令级并行及其开发" class="headerlink" title="3. 指令级并行及其开发"></a>3. 指令级并行及其开发</h1><h2 id="3-1-指令级并行的概念"><a href="#3-1-指令级并行的概念" class="headerlink" title="3.1 指令级并行的概念"></a>3.1 指令级并行的概念</h2><p>现代处理器都使用流水线来重叠指令的执行过程从而提高性能，由于指令可以并行执行，因此指令间可能实现的这种重叠称之为<strong>指令级并行</strong>（ILP）。</p>
<p>ILP大体有两种不同开发方法，一种是<strong>依靠硬件</strong>来帮助动态发现和开发并行，另一种是<strong>依靠软件技术</strong>在编译时静态发现并行。</p>
<p>一个流水线处理器的CPI值等于基本CPI与因为各种停顿而耗费的全部周期之和：</p>
<p><strong>流水线CPU&#x3D;理想流水线CPI+结构化停顿+数据冒险停顿+控制停顿</strong></p>
<p>因此要想提高流水线效率（即降低Pipeline CPI），可以从<strong>降低理想CPI</strong>和<strong>降低各类流水线阻塞周期</strong>这些方面入手。涉及到的部分技术如下：</p>
<table>
<thead>
<tr>
<th>技术</th>
<th>降低CPI的哪一组成部分</th>
</tr>
</thead>
<tbody><tr>
<td>转发和旁路</td>
<td>潜在的数据冒险停顿</td>
</tr>
<tr>
<td>延迟分支和简单分支调度</td>
<td>控制冒险停顿</td>
</tr>
<tr>
<td>基本编译器流水线调度</td>
<td>数据冒险停顿</td>
</tr>
<tr>
<td>基本动态调度（记分板）</td>
<td>由真相关引起的数据冒险停顿</td>
</tr>
<tr>
<td>循环展开</td>
<td>控制冒险停顿</td>
</tr>
<tr>
<td>分支预测</td>
<td>控制停顿</td>
</tr>
<tr>
<td>采用重命名的动态调度</td>
<td>由数据冒险、输出相关和反相关引起的停顿</td>
</tr>
<tr>
<td>硬件推测</td>
<td>数据冒险和控制冒险停顿</td>
</tr>
<tr>
<td>动态存储器消除二义</td>
<td>设计存储器的数据冒险停顿</td>
</tr>
<tr>
<td>每个周期发出多条指令</td>
<td>理想CPI</td>
</tr>
<tr>
<td>编译器相关性分析、软件流水线、踪迹调试</td>
<td>理想CPI、数据冒险停顿</td>
</tr>
<tr>
<td>硬件支持编译器推测</td>
<td>理想CPI、数据冒险停顿、分支冒险停顿</td>
</tr>
</tbody></table>
<h3 id="3-1-1-数据相关与冒险"><a href="#3-1-1-数据相关与冒险" class="headerlink" title="3.1.1 数据相关与冒险"></a>3.1.1 数据相关与冒险</h3><p>如果两条指令是并行的，只要流水线有足够资源（不存在结构冒险），就可以在一个任意深度的流水线中同时执行它们，不会导致任何停顿。如果这两条指令是相关的，它们就不是并行的，尽管它们通常可以部分重叠，但必须按照顺序执行。这两种情景的关键在于<strong>判断一条指令是否依赖于另一指令</strong>。</p>
<p>共有3种不同类型的相关，<strong>数据相关（真数据相关）、名称相关和控制相关</strong>。</p>
<h4 id="（1）数据相关"><a href="#（1）数据相关" class="headerlink" title="（1）数据相关"></a>（1）数据相关</h4><p>如果下面任一条件成立，则说指令j数据相关于指令i：</p>
<ul>
<li><p>指令i生成的结果可能会被指令j用到；</p>
</li>
<li><p>指令j数据相关于指令k，指令k数据相关于指令i。</p>
</li>
</ul>
<p>第二个条件就是说：如果两条指令之间存在第一类型的相关链，那么这两条指令也是相关的。如果两条指令是数据相关的，那它们必须按顺序执行，不能同时执行或不能完全重叠执行。</p>
<p>数据相关传递了三点信息：</p>
<ul>
<li><p>冒险的可能性</p>
</li>
<li><p>计算结果必须遵循的顺序</p>
</li>
<li><p>可开发并行度的上限</p>
</li>
</ul>
<p>我们可以通过以下两种方法来克服相关性：</p>
<ul>
<li><p>保护相关性但避免冒险</p>
</li>
<li><p>通过转换代码来消除相关性</p>
</li>
</ul>
<p><strong>对代码进行调度</strong>是在不修改相关性的情况下避免冒险的主要方法，可以由编译器来完成，也可以由硬件完成。</p>
<h4 id="（2）名称相关"><a href="#（2）名称相关" class="headerlink" title="（2）名称相关"></a>（2）名称相关</h4><p>当两条指令使用相同寄存器或者存储器位置（称为<strong>名称</strong>），但与该名称相关的指令之间并没有数据流动时，就会发生名称相关。在指令i和指令j（按照程序顺序，指令i在指令j之前）之间存在两种类型的名称相关。</p>
<ul>
<li><p>当指令j对指令i读取的寄存器或存储器位置执行写操作时就会在指令i和指令j之间发生<strong>反相关</strong>。为了确保i能读取到正确的取值，必须保持原来的顺序。</p>
</li>
<li><p>当指令i和指令j对同一个寄存器或存储器位置执行写操作时，发生<strong>输出相关</strong>。为了确保最后写入的值和指令j相对应，必须保持指令间的排序。</p>
</li>
</ul>
<p>由于没有在指令之间传递值，因此反相关和输出相关都是名称相关，与真数据相关相对。使用<strong>寄存器重命名</strong>就能解决名称相关，因此名称相关也不是真正的相关。</p>
<h4 id="（3）数据冒险"><a href="#（3）数据冒险" class="headerlink" title="（3）数据冒险"></a>（3）数据冒险</h4><p>只要指令间存在<strong>名称相关</strong>或者<strong>数据相关</strong>并且它们非常接近，足以使执行期间的重叠改变对相关操作数的访问顺序，那就会存在冒险。考虑两条指令i和j，其中i根据程序顺序排在j前面，可能出现的数据冒险为：</p>
<ul>
<li><p><strong>RAW</strong>（写后读）：j试图在i写入一个源位置<strong>之前</strong>读取它，所以j会错误地获取旧值，该冒险与真数据相关对应。</p>
</li>
<li><p><strong>WAW</strong>（写后写）：j试图在i写一个操作数<strong>之前</strong>写该操作数。这些写操作最终以错误顺序执行，最后留在目标位置的是由i写入的值，而不是j写入的值，该冒险与输出相关对应。</p>
</li>
<li><p><strong>WAR</strong>（读后写）：j试图在i读取一个目标位置<strong>之前</strong>写入该位置，所以i会错误地获取新值，该冒险与反相关对应。</p>
</li>
</ul>
<h3 id="3-1-2-控制相关"><a href="#3-1-2-控制相关" class="headerlink" title="3.1.2 控制相关"></a>3.1.2 控制相关</h3><p>最后一种相关是<strong>控制相关</strong>，控制相关决定了指令i相对于分支指令的顺序，使指令i按照正确的程序顺序执行，而且只会在应当执行时执行。一般来说，控制相关会施加下述两条约束条件。</p>
<ul>
<li><p>如果一条指令与一个分支控制相关，那就不能把这个指令转移到这个分支之前，使它的执行不再受控于这个分支。比如，不能把if语句then部分中的一条指令拿出来，然后转移到if语句前面。</p>
</li>
<li><p>如果一条指令与一个分支没有控制相关，那就不能把这个指令移到这个分支之后，使其受控于这个分支。比如，不能把if语句之前的一个语句移到它的then部分。</p>
</li>
</ul>
<p>对导致控制停顿的控制冒险进行检测，可以保持控制相关。控制停顿可以通过各种软硬件技术加以消除或减少。</p>
<p>通过保持数据相关和控制相关的底层逻辑在于保护<strong>异常行为</strong>和<strong>数据流</strong>这两个特性，这两个特性对程序的正确性至关重要。</p>
<h2 id="3-2-揭示ILP的基本编译器技术"><a href="#3-2-揭示ILP的基本编译器技术" class="headerlink" title="3.2 揭示ILP的基本编译器技术"></a>3.2 揭示ILP的基本编译器技术</h2><p>研究一些简单的编译器技术，用来提高处理器开发ILP的能力。这些技术对于使用静态发射或静态调度的处理器非常重要。</p>
<h3 id="3-2-1-基本流水线调度和循环展开"><a href="#3-2-1-基本流水线调度和循环展开" class="headerlink" title="3.2.1 基本流水线调度和循环展开"></a>3.2.1 基本流水线调度和循环展开</h3><p>为了使流水线保持满载，必须找出可以在流水线中重叠的不相关指令序列，充分开发指令并行。为了避免流水线停顿，必须将相关指令和源指令的执行隔开一定的时间周期，这一间隔应当等于源指令的流水线延迟。编译器执行这种调度的能力既依赖于程序中可用ILP的数目，也依赖于流水线中功能单元的延迟。</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230603135430.png"></p>
<p>调度的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">999</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    x[i]=x[i]+s;</span><br></pre></td></tr></table></figure>

<p>对于上面这个循环，其MIPS代码如下：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230603140142.png"></p>
<blockquote>
<p>注意，MIPS中的S.D，是将F4的值传回到0(R1)中，跟其他指令的理解顺序是反的。</p>
</blockquote>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230603140105.png"></p>
<p>通过调度指令，可以使这个循环只有两次停顿，耗费的时间缩减至7个时钟周期：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230603140233.png"></p>
<p>ADD.D之后的停顿是供S.D.使用的。在这个例子中，每7个时钟周期就完成一次循环迭代并存回一个数组元素，但对数组元素进行的实际运算仅占用这7个时钟周期中的3个（载入、求和与存储）。其余4个时钟周期包括循环开销（DADDUI和BNE）和两次停顿。为了消除这4个时钟周期，需要使循环体中的运算指令数多于开销指令数。</p>
<p>要提高运算指令相对于分支和开销指令的数目，一种简单的方案就是<strong>循环展开</strong>。展开就是将循环体复制多次，调整循环的终止代码。循环展开还可以用于提高调度效率，因为它消除了分支，可以将来自不同迭代的指令放在一起调度。</p>
<p>比如上文中的循环，对其进行展开，使其包含循环体的4个副本，假定R1-R2（即数组大小）最初是32的倍数，也就是说循环迭代的数目是4的倍数。消除任何明显的冗余计算，不要重复使用任何寄存器。</p>
<p>合并DADDUI指令，删除在展开期间重复的非必须BN运算，得到如下结果（DADDUI那里-32是因为循环了四次，因此指针应该递减32字节）：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230603172839.png"></p>
<p>值得注意的是，不能循环展开太多次，不然大多数执行时间都花费在未展开的循环体上了。</p>
<h2 id="3-3-用高级分支预测降低分支成本"><a href="#3-3-用高级分支预测降低分支成本" class="headerlink" title="3.3 用高级分支预测降低分支成本"></a>3.3 用高级分支预测降低分支成本</h2><p>由于需要通过分支冒险和停顿来实施控制相关，所以分支会伤害流水线性能。循环展开是一种降低分支冒险的方法，也能通过<strong>预测分支</strong>的行为方式来降低分支的性能损失。</p>
<p>常见的两位预测器的方案仅使用单个分支的最近行为来预测该分支的未来行为。如果我们<strong>同时还能查看其它分支的最近行为</strong>，而不是仅查看要预测的分支，那就有可能<strong>提高预测准确度</strong>。利用其它分支行为来进行预测的分支预测器称为<strong>相关预测</strong>或<strong>两级预测器</strong>。</p>
<p>比如如下代码及其MIPS代码：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230604162304.png"></p>
<p>将分支标记为b1、b2和b3。从中可以看出很重要的一点：<strong>分支b3的行为与分支b1和b2的行为有关</strong>。显然，如果分支b1和b2未执行转移（即其条件均为真，且aa和bb均被赋值为0），aa和bb明显相等，所以会进行b3分支转移。如果预测器仅利用一个分支的行为来预测分支结果，那显然不会捕获到这一行为。</p>
<p>(1,2)预测器在预测一个特定分支时，利用最近一个分支的行为从一对2位分支预测器中进行选择。一般情况下，(m,n)预测器利用最近m个分支的行为从2^m个分支预测器中进行选择，其中每个预测器都是单个分支的n位预测器。这种相关分支预测器的预测率高于两位预测器，并且添加很少的硬件就可实现。</p>
<p>其实现原理是：<strong>最近m个分支的全局记录可以记录在m位移位的寄存器中，其中每一位记录是否执行了该分支转移</strong>。将分支地址的低位与m位全局历史串联在一起，就可以对分支预测缓冲区进行寻址。例如在一个共有64项的(2,2)缓冲区中，分支的低4位地址(字地址)和2个全局位(表示最近执行的两个分支的行为)构成一个6位索引，可用来对64个计数器来进行寻址。</p>
<h2 id="3-4-用动态调度克服数据冒险"><a href="#3-4-用动态调度克服数据冒险" class="headerlink" title="3.4 用动态调度克服数据冒险"></a>3.4 用动态调度克服数据冒险</h2><p>除非是流水线中的已有指令与要提取的指令之间<strong>存在数据相关</strong>，<strong>而且无法通过旁路或转发来隐藏这一数据相关</strong>，否则，简单的静态调度流水线就会提取一条指令发射出去。如果存在不能隐藏的数据相关，那些冒险检测软件会从使用该结果的指令开始，将流水线置于停顿状态。</p>
<p>动态调度具有以下优点：</p>
<ul>
<li><p>允许针对一种流水线编译的代码在不同流水线上高效执行，不需要在使用不同微体系结构时重新进行编译。</p>
</li>
<li><p>在某些情况下，在编译代码时还不能知道相关性，利用动态调度可以处理某些此类情况。</p>
</li>
<li><p>允许处理器容忍一些预料之外的延迟，比如缓存缺失，它可以在等待解决缺失问题的时候执行其他代码。</p>
</li>
</ul>
<h3 id="3-4-1-动态调度的思想"><a href="#3-4-1-动态调度的思想" class="headerlink" title="3.4.1 动态调度的思想"></a>3.4.1 动态调度的思想</h3><p>简单流水线技术的一个主要限制就是它们使用<strong>循序指令发射和执行</strong>：指令按程序顺序发射，如果一条指令停顿在流水线中，后续指令不能继续进行。在经典五级流水线中，会在指令译码（ID）期间检查结构冒险和数据冒险，当一个指令可以无冒险执行并且所有数据冒险已经解决，才会从ID将其发射出去。</p>
<p>但很明显，这样停顿流水线的代价太大，我们需要想办法进行优化，优化点就落在了<strong>发射和执行</strong>上。首先，顺序发射是必须保留的，这可以让我们知道某条指令的结果会流向哪些指令，如果不顺序发射，可能会混淆RAW和WAR相关。其次，执行是可以乱序的，前面的指令在阻塞的时候（等待冒险消失），后面的指令已经发射并且其操作数可用时（即与前面的指令没有数据相关，也不存在结构冒险），我们可以让后面的指令先执行，这样一来就能大大提升流水线速度，这就是<strong>乱序执行</strong>。</p>
<p>为了能够实现乱序执行，我们将经典五级流水线的ID流水级大体分为以下两个阶段：</p>
<ul>
<li><p><strong>发射</strong>——译码指令，检查结构性冒险。</p>
</li>
<li><p><strong>读操作数</strong>——直到没有数据冒险才读取操作数。</p>
</li>
</ul>
<h2 id="3-5-Tomasulo算法"><a href="#3-5-Tomasulo算法" class="headerlink" title="3.5 Tomasulo算法"></a>3.5 Tomasulo算法</h2><p>从之前ScoreBoard算法中的结构图可以知道，每一个运算部件都只拥有一个OPRAND流水段寄存器，也只拥有一个译码信息流水段寄存器，这意味着多配置处理器中的每一条配置通路同一时间只能存在一条指令，如果某一配置通路被占据，而INST中又来一条该配置通路的对应指令，那这条指令就没法发射到配置通路上（即没办法发射到译码信息流水段寄存器中，如MUL_1等），从而导致指令发射停滞，指令流截断。这样会大大地影响处理器性能。</p>
<p>而且ScoreBoard为了乱序执行指令，在碰到WAW、WAR这两个冒险（假冒险）的时候也会暂停流水线，而这其实是不必要的，因此记分牌算法还是没有最大限度地挖掘出指令的乱序潜力。而且记分牌的“写回”是乱序的，乱序完成指令不利于处理器处理中断、异常等情况，不利于程序员debug程序。</p>
<p>WAW和WAR之所以是假冒险，是因为写后写和读后写都可以通过修改目的寄存器来解决阻塞问题（<strong>非真相关</strong>）。而RAW由于存在<strong>数据相关</strong>，即后序指令读取的数据由前序指令算得，这个过程有明确的数据依赖，因此是真冒险。</p>
<p>因此想要充分发挥乱序执行的性能，就要消除假数据相关，消除假数据相关的主要方法是<strong>寄存器重命名</strong>——发生WAW时找一个新的寄存器存放新值，发生WAR时也找一个新的寄存器存放新值，即对目标寄存器（包括较早指令正在读取或写入的寄存器）进行重命名。这样一来，乱序写入不会影响到任何依赖某一操作数较早值的指令，从而消除WAR和WAW冒险。</p>
<p>在Tomasulo算法中，寄存器重命名的功能由<strong>保留站</strong>提供，保留站会为等待发射的指令缓冲操作数。其基本思想是：保留站在一个操作数可用时马上提取并缓存它，这样就不再需要从寄存器中获取该操作数。此外，等待执行的指令会指定保留站，为自己提供输入。最后，在对寄存器连续进行写入操作并且重叠执行时，只会实际使用最后一个操作更新寄存器。在发射指令时，会将待用操作数的寄存器说明符更名，改为保留站的名字，这就实现了寄存器重命名。</p>
<p><img src="https://pic2.zhimg.com/80/v2-7c9ec91e4b9d9a052d39fcde3a2316c1_1440w.webp"></p>
<p>该结构图中：</p>
<ul>
<li><p>FP OP Queue：是浮点指令队列，指令在这里等待发射。</p>
</li>
<li><p>Reservation Stations（绿色模块）：加法单元和乘法单元的保留站，保留已经发射的指令的信息和缓冲下来的数据。</p>
</li>
<li><p>Address Unit：地址计算单元，在这个算法中存储指令在执行前会先计算好存储地址。</p>
</li>
<li><p>Memory Unit：存储单元。</p>
</li>
<li><p>CDB：公共数据总线，它可以直达寄存器堆（用来更新通用寄存器）、加法乘法存储单元的保留站（输送保留站中指令需要的数据）。</p>
</li>
</ul>
<p>同样的，Tomasulo算法的核心在于<strong>保留站（Reservation Stations）</strong>，也是新的硬件部件，同样分为三个部分：</p>
<p><img src="https://img-blog.csdnimg.cn/20190513164540984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2OTQ1NTky,size_16,color_FFFFFF,t_70"></p>
<table>
<thead>
<tr>
<th>Busy</th>
<th>Op</th>
<th>Qj</th>
<th>Qk</th>
<th>Vj</th>
<th>Vk</th>
</tr>
</thead>
<tbody><tr>
<td>指示部件是否空闲</td>
<td>该部件的操作</td>
<td>产生源操作数的寄存器，用寄存器对应的保留站代替表示</td>
<td>产生源操作数的寄存器，用寄存器对应的保留站代替表示</td>
<td>源操作数的值。Store 缓冲区有Vk域，用于存放要写入存储器的值</td>
<td>源操作数的值。Store 缓冲区有Vk域，用于存放要写入存储器的值</td>
</tr>
</tbody></table>
<p>注意，V和Q同时只能存在一个，如果寄存器中有需要的源操作数，那么更新V，如果寄存器没有，那么更新Q（保留站名称），表明该寄存器将由哪个保留站的中的指令。</p>
<p><strong>Tomasulo算法的调度分为三个步骤：发射、执行、写回</strong>。相比记分牌少了读数（读取操作数）这个环节，因为在Tomasulo中指令在发射时就会读数。</p>
<ul>
<li><p>发射：从指令队列的头部获取下一条指令，按照FIFO顺序发射。发射的唯一标准是指令对应通路的保留站是否有空位（<strong>解决结构冒险</strong>）。只要保留站有空余，就可以把指令发射到保留站中，如果指令对应的操作数已经存于当前寄存器中，那么一并发送到保留站中。如果没有空保留站，那就存在结构冒险，该指令会停顿，直到有保留站或者缓冲区被释放为止。如果操作数不在寄存器中，那么就一直跟踪将生成这些操作数的功能单元。这一步骤将对寄存器重命名，<strong>消除WAR和WAW冒险</strong>。</p>
</li>
<li><p>执行：指令获得所有操作数（通过拷贝数据和监听CDB，当任一操作数可用就放进保留站中）后，立即执行，可能经历多个周期才执行完成。通过延迟指令执行，直到操作数可用为止，这用就<strong>避免了RAW冒险</strong>。</p>
</li>
<li><p>写回：当计算结果出来之后，将其写到CBD上，再由CBD传送给寄存器和任意等待这一结果的保留站（包括存储缓冲区）。存储指令一直缓存在存储缓冲区中，知道待存储值和存储地址可用为止，然后在有空闲存储器单元时，立即写入结果。</p>
</li>
</ul>
<p>综上，<strong>Tomasulo</strong>优劣在于：</p>
<ul>
<li><p>第一个优点，<strong>冒险检测逻辑的分布</strong>（分布式）。这个优点源于采用了分布式保留站和CDB。如果多条指令正在等待同一个结果，而每条指令的其他操作数均已准备就绪，那么在CDB上广播这一结果就可以同时释放这些指令。如果使用集中式寄存器堆，这些单元必须在寄存器总线可用时再从寄存器中读取自己的结果。</p>
</li>
<li><p>第二个优点，<strong>消除了可能产生WAW和WAR冒险的停顿</strong>。这个优点源于利用保留站实现了重命名寄存器，并在操作数可用时立即将其存储在保留站中。</p>
</li>
<li><p>第一个缺点，<strong>整个方案比较复杂</strong>。Tomasulo既要大量的硬件，比如每个保留站都要一个高速运转的相关缓冲区，既要复杂的控制逻辑来实现这个算法。</p>
</li>
<li><p>第二个缺点，<strong>性能受限于CDB</strong>。无论是监听CDB获取操作数还是通过CDB写回计算结果，CDB的速率决定性能上限。</p>
</li>
</ul>
<p>最后给出Tomasulo和Scoreboard的对比：</p>
<table>
<thead>
<tr>
<th>Tomasulo (IBM 360&#x2F;91)</th>
<th>Scoreboard (CDC 6600)</th>
</tr>
</thead>
<tbody><tr>
<td>流水化的功能部件<br>(6 load, 3 store, 3 +, 2 x&#x2F;÷)</td>
<td>多个功能部件<br>(1 load&#x2F;store, 1 + , 2 x, 1 ÷,…)</td>
</tr>
<tr>
<td>指令窗口较大</td>
<td>指令窗口较小</td>
</tr>
<tr>
<td>有结构冲突时不发射</td>
<td>有结构冲突时不发射</td>
</tr>
<tr>
<td>WAR：用寄存器重命名避免</td>
<td>WAR：stall 来避免</td>
</tr>
<tr>
<td>WAW：用寄存器重命名避免</td>
<td>WAW：停止发射</td>
</tr>
<tr>
<td>从FU广播结果</td>
<td>写寄存器方式</td>
</tr>
<tr>
<td>Control：RS（保留站）</td>
<td>集中式scoreboard</td>
</tr>
</tbody></table>
<h3 id="3-5-1-Tomasulo算法：基于循环的展示"><a href="#3-5-1-Tomasulo算法：基于循环的展示" class="headerlink" title="3.5.1 Tomasulo算法：基于循环的展示"></a>3.5.1 Tomasulo算法：基于循环的展示</h3><blockquote>
<p>设Multiply执行阶段4 clocks，第一次load需要8 clocks(cache miss)，第2次以后假设命中(hit)。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Loop: LD F0, 0(R1)</span><br><span class="line">      MULTD F4, F0, F2</span><br><span class="line">      SD F4, 0(R1)</span><br><span class="line">      SUBI R1,R1,#8</span><br><span class="line">      BNEZ R1 Loop</span><br></pre></td></tr></table></figure>

<p>对其循环部分进行循环展开，如图所示：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230605153453.png"></p>
<p>通过Tomasulo，即使迭代1还没计算出结果，但是迭代2也能同时在计算自己的结果，这大大提高了运行速度。</p>
<p>用代码表达这个循环展开就是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 展开前</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">999</span>;i&gt;=<span class="number">1</span>;i-=<span class="number">2</span>)</span><br><span class="line">    x[i]=x[i]+s;</span><br><span class="line"><span class="comment">// 展开</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">999</span>;i&gt;=<span class="number">1</span>;i-=<span class="number">2</span>)&#123;</span><br><span class="line">    x[i]=x[i]+s;</span><br><span class="line">    x[i<span class="number">-1</span>]=x[i<span class="number">-1</span>]+s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="A-指令集基本原理"><a href="#A-指令集基本原理" class="headerlink" title="A. 指令集基本原理"></a>A. 指令集基本原理</h1><blockquote>
<p>从上到下，我们可以将计算机系统分为四个层次，分别为应用软件、 基础软件、 硬件电路和物理载体。软件以指令形式运行在 CPU 硬件上，而指令集(ISA)介于软件和硬件之间，是软硬件交互的界面，有着非常关键的作用。</p>
</blockquote>
<h2 id="A-1-指令集体系结构的分类"><a href="#A-1-指令集体系结构的分类" class="headerlink" title="A.1 指令集体系结构的分类"></a>A.1 指令集体系结构的分类</h2><p>在<strong>栈体系结构</strong>中操作数隐式位于栈的顶部，而在<strong>累加器体系结构</strong>中，操作数隐式为累加器。<strong>通用寄存器体系结构</strong>只有显式操作数，或者为寄存器，或者为存储器位置。</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230602164312.png"></p>
<p>现代计算机基本采用通用寄存器体系结构，这是因为寄存器快于存储器，并且对于编译器来说，使用寄存器要比使用其他内部存储形式的效率更高。最重要的是，寄存器可以用于保存变量，减少访问存储器的次数从而提高程序速度。</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230602164625.png"></p>
<p>当然通用寄存器计算机也有不同的分类，各有优劣。</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230602165126.png"></p>
<h2 id="A-2-存储器寻址"><a href="#A-2-存储器寻址" class="headerlink" title="A.2 存储器寻址"></a>A.2 存储器寻址</h2><p>寻址方式如图所示：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164544.png"></p>
<p>如果对寻址方式进行总结，分为不同<strong>寻址模式</strong>，MIPS的寻址模式如下：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230602191726.png"></p>
<p>值得注意的是，如指令bge x15, x14, -56，为PC相对寻址，地址应为PC + (-56 &lt;&lt; 2)，之所以要右移是因为这-56是指令偏移量，一条指令4字节，因此要*4。</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164551.png"></p>
<h2 id="A-3-指令集编码"><a href="#A-3-指令集编码" class="headerlink" title="A.3 指令集编码"></a>A.3 指令集编码</h2><p>MIPS64有32个64位通用寄存器（GPR），即R0…。GPR有时也称为整数寄存器。此外还有一组32位浮点寄存器（FPR），即F0…。MIPS数据类型包括8位字节、16位半字、32位字和64位双字整型数据和32位单精度与64位双精度浮点数据。其寻址方式是立即数寻址和位移寻址，均采用16位字段。 <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164605.png"></p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164613.png"></p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164630.png"></p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164637.png"></p>
<p>同时给出RISC-V的指令集编码：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230602192952.png"></p>
<p>opcode：操作码，占了7bit。</p>
<p>rd (Destination Register)：目的寄存器，占了5bit。</p>
<p>funct3&#x2F;funct7：两个操作字段。funct3占了3bit，funct7占了7bit。</p>
<p>rs1 (Source Register 1)：第一个源操作数寄存器，占了5bit。</p>
<p>rs2 (Source Register 2)：第二个源操作数寄存器，占了5bit。</p>
<p>imm：立即数，视情况而决定。</p>
<h1 id="B-存储器层次结构"><a href="#B-存储器层次结构" class="headerlink" title="B. 存储器层次结构"></a>B. 存储器层次结构</h1><h2 id="B-1-缓存的概念"><a href="#B-1-缓存的概念" class="headerlink" title="B.1 缓存的概念"></a>B.1 缓存的概念</h2><p><strong>缓存</strong>是指地址离开处理器后遇到的最高级或第一级存储器层次结构，其设计是基于局域性原理来提高性能。如果处理器在缓存中找到了所需要的数据项，那么就说发生了<strong>缓存命中</strong>。如果没找到，那就是<strong>缓存缺失</strong>。</p>
<h3 id="B-1-1-块的放置（缓存组织方式）"><a href="#B-1-1-块的放置（缓存组织方式）" class="headerlink" title="B.1.1 块的放置（缓存组织方式）"></a>B.1.1 块的放置（缓存组织方式）</h3><p>根据对块的放置位置的限制，可以将缓存组织方式氛围以下三类：</p>
<ul>
<li><p><strong>直接映射</strong>：每个块只能出现在缓存中的一个位置，映射关系是：</p>
<p>（块地址）MOD （缓存中的块数）</p>
</li>
<li><p><strong>全相联</strong>：一个块可以放在缓存中的任意位置。</p>
</li>
<li><p><strong>n路组相联</strong>：一个块可以放在缓存中由有限个位置组成的<strong>组</strong>（set）内，则该缓存是组相联。组就是缓存中的一组块，块首先映射到组，然后这个块可以放在这个组中的任意位置。通常以<strong>位选择方式</strong>来选定组，映射关系是：</p>
<p>（块地址）MOD （缓存中的组数）</p>
<p>如果组中有n个块，则称该缓存放置为n路组相联。</p>
</li>
</ul>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230605161439.png"></p>
<h3 id="B-1-2-块的识别"><a href="#B-1-2-块的识别" class="headerlink" title="B.1.2 块的识别"></a>B.1.2 块的识别</h3><p>当我们从内存中提取数据放入到缓存中，我们是如何判断这个数据应该放到哪个缓存块中的呢？又或者说，我们要从某个缓存块中提取数据，我们如何快速找到这个缓存块？</p>
<p>我们可以将内存地址分为三个部分：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230605162551.png"></p>
<p>**标志(tag)**：用来确定是否与匹配，如果所请求的缓存块的tag和当前缓存块的tag相等那就是缓存命中。</p>
<blockquote>
<p>假如使用的是32位内存地址的计算机，那么tag所占的位数是：tag&#x3D;32-index-offest</p>
</blockquote>
<p>**缓存索引(cache index)**：用于索引是缓存中的哪个组（全相联没有索引字段）。</p>
<blockquote>
<p>index所占位数可以用 log_2(缓存大小&#x2F;组大小(块大小)) 得出，比如说128KB的缓存，每个块大小是64B</p>
<p>直接映射：128KB&#x2F;64B&#x3D;2048，2^11&#x3D;2048，因此index占11位</p>
<p>组相联：对于2路组相联，128KB&#x2F;(64B*2)&#x3D;1024，2^10&#x3D;1024，因此index占10位</p>
</blockquote>
<p>**块偏移(block offset)**：用于表示块中所需数据的地址，因为缓存块一般比较大，通常包含32字节或64字节，而指令或数据访问往往没有这么宽，需要通过Offset来指定访问对象在块内的具体位置。</p>
<blockquote>
<p>offset所占位数可用 log_2(块大小) 得出，比如说块大小是64B，2^6&#x3D;64，因此offset占6位</p>
</blockquote>
<p>假如给出访问地址，让我们要判断缓存中的数据是否命中，要用以下方法来进行判断：</p>
<ul>
<li><p>在直接相联结构中，访问地址的Tag仅需要和Index索引的那个Cache块的Tag比较。</p>
</li>
<li><p>在全相联结构中，Index位数为0，访问地址的Tag需要和每个Cache块的Tag比较，如果相等就给出命中信号Hit，同时将命中项的Cache块的Data通过Mux（多路选择器，Multiplexer）选出。</p>
</li>
<li><p>在组相联结构中，访问地址的Tag需要和每一组中Index索引的那个Cache块的Tag比较，生成Hit信号并选出命中项的Data。</p>
</li>
</ul>
<h3 id="B-1-3-块的替换"><a href="#B-1-3-块的替换" class="headerlink" title="B.1.3 块的替换"></a>B.1.3 块的替换</h3><p>当发生缓存缺失时，缓存控制器必须选择一个用期望数据替换的块。对于全相联或者组相联布置方式，在发生缺失时会有许多块可供选择。一般采用以下三种策略来选择替换哪个块：</p>
<ul>
<li><p><strong>随机</strong>：为进行<strong>均匀分配</strong>，候选块是随机选择的。一些系统生成伪随机编号，以实现可重复的行为，这在调试硬件时有一定用处。</p>
</li>
<li><p><strong>最近最少使用（LRU）</strong>：为尽量避免抛弃不久就会用到的信息，会记录下对数据块的访问。依靠过去的行为来预测未来，将替换掉未使用时间最久的块。LRU依赖于局域性的一条推论：如果最近用过的块很可能被再次用到，那么放弃最近最少使用的块是一种不错的选择。</p>
</li>
<li><p><strong>先入先出（FIFO）</strong>：因为LRU的计算十分复杂，所以这一策略是通过确定最早的块来近似LRU，而不是直接确定LRU。</p>
</li>
</ul>
<p>随机替换实现简单，而LRU随着跟踪块数的增加，成本也越来越高，只能采用近似法。一种常用的近似方法是，为缓存中的每个组设定一组比特，每个比特对应于缓存中的一路（四路组相联中，一组有四个块，每个块为一路）。在访问一组时开启一个特定比特，这一比特与包含所需块的路相对应。如果与一个组相关联的所有比特都被开启，除最近刚被开启的比特之外，将所有其他比特关闭。在必须替换一个块时，处理器从相应被关闭的路中选择一个块，如果有多种选择，则随机选定。</p>
<h3 id="B-1-4-写入策略"><a href="#B-1-4-写入策略" class="headerlink" title="B.1.4 写入策略"></a>B.1.4 写入策略</h3><p>当我们需要把数据更新写回缓存时，考虑到性能问题，我们有两种写入策略：</p>
<ul>
<li><p><strong>直写</strong>——信息被写入缓存中的块和低一级存储器中的块。</p>
</li>
<li><p><strong>写回</strong>——信息仅被写到缓存中的块。修改后的缓存块仅在被替换时才被写到主存储器。</p>
</li>
</ul>
<p>为了减少在替换时写回块中的频率，通常会用一种叫脏位的功能。如果这一状态位为脏（被修改过）时，被替换时会写到主存储器。如果这一状态位为干净（未被修改）时，不会写到主存储器中。</p>
<p>使用写回策略，由于一些写入内容不会进入到存储器，所以使用存储器带宽较少，这对于多处理器十分有利。其次写回对存储器层次结构其余部分及存储器互联的使用少于直写，所以它还可以节省功耗。</p>
<p>使用直写策略，实现起来更容易，并且下一级存储器拥有数据的最新副本，从而简化了数据一致性。</p>
<p>由于在写入时并不需要数据，所以在发生写入缺失时有以下两种选项：</p>
<ul>
<li><p><strong>写入分派</strong>——在发生写入缺失时该块读取到缓存中，随后对其执行写入命中操作。在该选项中，写入缺失和读取缺失类似。</p>
</li>
<li><p><strong>无写入分派</strong>——这是一种不太寻常的选项，<strong>写入缺失不会影响到缓存</strong>。而是仅修改低一级存储器中的块。</p>
</li>
</ul>
<p>因此在采用无写入分派策略时，在程序试图读取块之前，这些块一直都在缓存之外，但在采用写入分派策略时，即使那些仅被写入的块也会保存到缓存中。举个例子理解：</p>
<p>在一个拥有许多缓存项的全相联写回缓存中，刚开始为空，有以下操作序列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Write Mem[100]</span><br><span class="line">Write Mem[100]</span><br><span class="line">Read  Mem[200]</span><br><span class="line">Write Mem[200]</span><br><span class="line">Write Mem[100]</span><br></pre></td></tr></table></figure>

<p>使用<strong>无写入分派</strong>：由于写入不进行分派，因此前面两次对地址100的写入都是miss。读取地址200时发生miss，miss之后会将地址200的数据放到缓存中，再对地址200进行写入时，此时就是hit。最后对地址100的写入也是miss。总共4次缺失，1次命中。</p>
<p>使用<strong>写入分派</strong>：就是正常思路，第一次地址100写入miss后，后面对地址100的操作都是hit。同理，第一次对地址200读取miss后，后面对地址200的操作都是hit。因此总共2次缺失，3次命中。</p>
<h2 id="B-2-缓存的性能"><a href="#B-2-缓存的性能" class="headerlink" title="B.2 缓存的性能"></a>B.2 缓存的性能</h2><p>评估缓存性能的度量标准是<strong>存储器平均访问时间</strong>：</p>
<p><strong>存储器平均时间&#x3D;命中时间+缺失时间*缺失代价</strong></p>
<h3 id="B-2-1-存储器平均访问时间和处理器性能"><a href="#B-2-1-存储器平均访问时间和处理器性能" class="headerlink" title="B.2.1 存储器平均访问时间和处理器性能"></a>B.2.1 存储器平均访问时间和处理器性能</h3><p>一个显而易见的问题是：因缓存缺失导致的存储器平均访问时间能否预测处理器性能。</p>
<p>首先，导致停顿的原因很多，我们得先假设所有存储器停顿都是缓存缺失所导致的。其次，处理器本身也会影响存储器平均访问时间。采用循序执行的处理器在缺失期间停顿，因此存储器停顿和存储器平均访问时间有强相关性，此处假定使用的是循序执行。</p>
<p>综上可以给出如下CPU时间公式：</p>
<p><strong>CPU时间&#x3D;（CPU执行时钟周期+存储器停顿时钟周期）*时钟周期时间</strong></p>
<p>等价于：</p>
<p><strong>CPU时间&#x3D;IC<em>（CPI执行+存储器停顿时钟周期&#x2F;指令数）</em>时钟周期时间</strong></p>
<p>由上述式子可知，当CPI越低，固定数目的缓存缺失时钟周期产生的相对影响越高。在计算CPI时，一次缺失的缓存缺失代价是以处理器时钟周期来计算的，因此时钟频率高的处理器在每次缺失时会占用较多的时钟周期，CPI的存储器部分也相应较高。对于低CPI，高时钟频率的处理器来说，缓存十分重要。</p>
<h3 id="B-2-2-缺失代价和乱序执行处理器"><a href="#B-2-2-缺失代价和乱序执行处理器" class="headerlink" title="B.2.2 缺失代价和乱序执行处理器"></a>B.2.2 缺失代价和乱序执行处理器</h3><p>对于乱序执行的处理器，需要重新定义存储器停顿，得到缺失代价的新定义，将其表示为非重叠延迟：</p>
<p><strong>存储器停顿周期&#x2F;指令数&#x3D;缺失数&#x2F;指令数*（总缺失代价-重叠缺失延迟）</strong></p>
<p>虽然乱序执行的处理器十分复杂，因此一些定义并不准确且唯一，但是再相关题目中，需要明确：</p>
<p><strong>存储器延迟长度</strong>——在乱序处理器中如何确定存储器操作的起止时刻。</p>
<p><strong>延迟重叠的长度</strong>——如何确定与处理器相重叠的起始时刻（即什么时刻能确定存储器操作使处理器停顿）。</p>
<p>最后给出B.2的公式总结：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230605205540.png"></p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230605205549.png"></p>
<h2 id="B-3-6种基本的缓存优化"><a href="#B-3-6种基本的缓存优化" class="headerlink" title="B.3 6种基本的缓存优化"></a>B.3 6种基本的缓存优化</h2><p><strong>存储器平均时间&#x3D;命中时间+缺失时间*缺失代价</strong></p>
<p>基于上面的公式，可以给出6种优化，并将它们分为以下3类：</p>
<ul>
<li><p><strong>降低缺失率</strong>——较大的块、较大的缓存、较高的关联度。</p>
</li>
<li><p><strong>降低缺失代价</strong>——多级缓存，将读取操作的优先级设定为高于写入操作。</p>
</li>
<li><p><strong>缩短在缓存中命中的时间</strong>——在索引缓存时避免地址转换。</p>
</li>
</ul>
<p>对于缺失我们也可以简单分为3类：</p>
<ul>
<li><p><strong>强制缺失</strong>——在第一次访问某个块时，他不可能会在缓存中，所以必须将其读到缓存中。这种缺失也被称为冷启动缺失或首次引用缺失。</p>
</li>
<li><p><strong>容量缺失</strong>——如果缓存无法容纳程序执行期间所需的全部块，由于一些块会被放弃，过后再另行提取，所以会（在强制缺失之外）发生容量缺失。</p>
</li>
<li><p><strong>冲突缺失</strong>——如果块布置策略为组相联或者直接映射，则会（在强制缺失和容量缺失之外）发生冲突缺失，这是因为如果有太多块被映射到一个组中，这个组中的某个块可能会被放弃，过后再另行提取。冲突缺失也称为碰撞缺失。</p>
</li>
</ul>
<h3 id="B-3-1-第一种优化方法：增大块大小以降低缺失率"><a href="#B-3-1-第一种优化方法：增大块大小以降低缺失率" class="headerlink" title="B.3.1 第一种优化方法：增大块大小以降低缺失率"></a>B.3.1 第一种优化方法：增大块大小以降低缺失率</h3><p>降低缺失率的最简单方法是增大块大小，之所以会降低，是因为较大的块充分利用了空间局域性的优势。但是较大的块也会增加缺失代价，这是因为降低了缓存中的块数，所以较大块可能会增大冲突缺失，如果缓存很小，甚至还会增加容量缺失。</p>
<p>块大小的选择有赖于低级存储器的延迟和带宽。高延迟和高带宽鼓励采用大块，因为缓存在每次缺失时能够获取的字节可以多出许多，而缺失代价却很少增加。相反，低延迟和低带宽则鼓励采用小块，因为这种情况下采用较大块并不会节省多少时间，更小的块还可能减少冲突缺失。</p>
<h3 id="B-3-2-第二种优化方法：增大缓存以降低缺失率"><a href="#B-3-2-第二种优化方法：增大缓存以降低缺失率" class="headerlink" title="B.3.2 第二种优化方法：增大缓存以降低缺失率"></a>B.3.2 第二种优化方法：增大缓存以降低缺失率</h3><p>降低容量缺失最明显的方法就是增加缓存的容量，但缺点也很明显，会延长命中时间、增加成本和功耗。这一技术一般用于片外缓存。</p>
<h3 id="B-3-3-第三种优化方法：提高相联度以降低缺失率"><a href="#B-3-3-第三种优化方法：提高相联度以降低缺失率" class="headerlink" title="B.3.3 第三种优化方法：提高相联度以降低缺失率"></a>B.3.3 第三种优化方法：提高相联度以降低缺失率</h3><p>根据统计数据，可以发现缺失率随着相联度增大而得到改善。从中可以看出两个一般性的经验规律：</p>
<ul>
<li><p>对于特定大小的缓存，从实际降低缺失数的功效来说，八路组相联和全相联是一样有效的。</p>
</li>
<li><p><strong>2:1缓存经验规律</strong>：大小为N的直接映射缓存与大小为N&#x2F;2的两路组相联缓存具有大体相同的缺失率。</p>
</li>
</ul>
<p>与许多此类示例类似，要改善存储器平均访问时间的一个方面，可能会导致另一方面的恶化。增大块大小可以降低缺失率，但会提高缺失代价；增大相联度可能会延长命中时间。因此，加快处理器时钟速度的压力鼓励使用简单的缓存设计，但提高相联度的回报是提高缺失代价（书本的脑残机翻，原文是“the pressure of a fast processor clock cycle encourages simple cache designs, but the increasing miss penalty rewards associativity, as the following example suggests.”意思是，基于人们对加快处理器时钟的迫切需求，我们鼓励使用简单的缓存设计，但是提高相联度的回报是提高缺失代价）。</p>
<h3 id="B-3-4-第四种优化方法：采用多级缓存降低缺失代价"><a href="#B-3-4-第四种优化方法：采用多级缓存降低缺失代价" class="headerlink" title="B.3.4 第四种优化方法：采用多级缓存降低缺失代价"></a>B.3.4 第四种优化方法：采用多级缓存降低缺失代价</h3><p>由于处理器的速度增长快于DRAM，从而使缺失代价的相对成本随时间的推移而升高。处理器和存储器之间的性能差距让架构师不得不开始思考：是应当加快缓存速度来和处理器的速度相匹配？还是让缓存再大一些，以避免处理器与主存储器之间的差距被再度拉大？</p>
<p>我们可以通过<strong>多级缓存</strong>来同时实现上述两个方案，在原缓存和存储器之间再添加一级缓存。第一级缓存可以小到足以与快速处理器的时钟周期时间相匹配，而第二级缓存则大到足以捕获本来可能进入主存储器的访问，从而降低实际缺失代价。</p>
<p>由于多加了一级缓存，性能公式也做出变化：</p>
<p>存储器平均访问时间&#x3D;命中时间_{L1}+缺失率_{L1}*缺失代价_{L1}</p>
<p>缺失代价_{L1}&#x3D;命中时间_{L2}+缺失率_{L2}*缺失代价_{L2}</p>
<p>由上述两式化简可得：</p>
<p>存储器平均访问时间&#x3D;命中时间_{L1}+缺失率_{L1}*(命中时间_{L2}+缺失率_{L2}*缺失代价_{L2})</p>
<p>在这个公式中，第二级缺失率是针对第一级缓存中未能找到的内容进行测量的，为避免含义模糊，对二级缓存系统采用以下术语。</p>
<ul>
<li><p><strong>局部缺失率</strong>——此比值即是缓存中的缺失数除以对该缓存进行存储器访问的总数。可以想到，对于第一级缓存，它等于缺失率L1，对于第二级缓存，它等于缺失率L2。</p>
</li>
<li><p><strong>全局缺失率</strong>——缓存中的缺失数处理处理器生成的存储器访问总数。利用以上术语，第一级缓存的全局缺失率依旧是缺失率L1，而第二级缓存则为缺失率L1*缺失率L2。</p>
</li>
</ul>
<p>每条指令的平均存储器停顿时间&#x3D;每条指令的缺失数_{L1}*命中时间_{L2}+每条指令的缺失数_{L2}*缺失代价_{L2}</p>
<p>对于第二级缓存，命中数要比第一级缓存中少得多，所以重心更多地偏向减少缺失。因为这一认知，人们开始采用大得多的缓存和降低缺失率的技术，比如更高的相联度和更大的块。</p>
<h3 id="B-3-5-第五种优化方法：使读取缺失的优先级高于写入缺失，以降低缺失代价"><a href="#B-3-5-第五种优化方法：使读取缺失的优先级高于写入缺失，以降低缺失代价" class="headerlink" title="B.3.5 第五种优化方法：使读取缺失的优先级高于写入缺失，以降低缺失代价"></a>B.3.5 第五种优化方法：使读取缺失的优先级高于写入缺失，以降低缺失代价</h3><p>这一优化方法在完成写入操作之前就可以为读取操作提供服务，我们先看一下写入缓冲区的复杂性。采用直写缓存时，最重要的改进就是一个大小合适的写入缓冲区。但是，由于写入缓冲区可能包含读取缺失时所需要的更新值，所以它们的确会使存储器访问变得复杂。</p>
<p>看以下操作序列，假如有一个直接映射直写缓存，它将512和1024映射到同一个块中，假定有一个四字写入缓存区，在读取缺失时不会进行检查。R2的值是否总是等于R3的值？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SW R3,512(R0)  M[512]&lt;-R3  (cache index 0)</span><br><span class="line">LW R1,1024(R0) R1&lt;-M[1024] (cache index 0)</span><br><span class="line">LW R2,512(R0)  R2&lt;-M[512]  (cache index 0)</span><br></pre></td></tr></table></figure>

<p>R3的数据在存储之后被写入缓冲区中。随后的载入操作使用相同的缓存索引，因此产生一次缺失。第二条载入指令尝试将位置512处的值放到寄存器R2中，这样也会导致一次缺失。如果写入缓冲区还没有完成向存储器中位置512的写入，对位置512的读取就会将错误的旧值放到缓存块中，然后再放入R2中。如果没有事先防范，R3是不等于R2的，这就是RAW冒险。</p>
<p>摆脱这一两难境地的最简单方法就是让读取缺失一直等待到写入缓冲区为空为止。一种替代方法就是在发生读取缺失时检查写入缓冲区的内容，如果没有冲突且存储器系统可用，则让读取缺失继续。几乎所有桌面与服务器处理器都可使用后一方法，使读取操作的优先级高于写入操作。</p>
<p>处理器在写回缓存中的写入成本也可以继续降低。假定一次读取缺失将替换一个脏服务器块。我们不是将这个脏块写到存储器中，然后再读取存储器，而是将这个脏块复制到缓冲区中，然后读存储器，再写存储器。这样，处理器的读取操作将会很快结束（处理器可能正在等待这一操作的完成）。和前一种情况类似，如果发生了读取缺失，处理器或者停顿到缓冲区为空，或者检查缓冲区中各个字的地址，以了解是否存在冲突。</p>
<h3 id="B-3-6-第六种优化方法：避免在索引缓存期间进行地址转换，以缩短命中时间"><a href="#B-3-6-第六种优化方法：避免在索引缓存期间进行地址转换，以缩短命中时间" class="headerlink" title="B.3.6 第六种优化方法：避免在索引缓存期间进行地址转换，以缩短命中时间"></a>B.3.6 第六种优化方法：避免在索引缓存期间进行地址转换，以缩短命中时间</h3><p>命中时间会影响处理器的时钟频率，因此它是至关重要的。现代处理器中，缓存访问时间限制都限制了时钟频率，即使那些使用多个时钟周期来访问缓存的处理器也是如此。因此，缩短命中时间可以对各个方面都提供帮助。</p>
<p>即使一个小而简单的缓存，也必须能够将来自处理器的虚拟地址转换为用以访问存储器的物理地址。根据“加快常见情景速度”这一指导原则，我们为缓存使用虚拟地址，因为命中的出现频率当然远高于缺失。这种缓存称为<strong>虚拟缓存</strong>，<strong>物理缓存</strong>则用于表示使用物理地址的传统缓存。</p>
<p>那么<strong>索引缓存</strong>和<strong>对比地址</strong>就是需要重点关注的任务，问题在于索引缓存中是应当使用虚拟地址还是物理地址，标志对比中应当使用虚拟地址还是物理地址？一种<strong>使虚拟缓存与物理缓存均能实现最佳性能</strong>的方法是使用一小部分页偏移量（也就是虚拟地址与物理地址保持一致的那一部分）来索引缓存。在使用索引读取缓存的同时，地址的虚拟部分被转换，标志匹配使用了物理地址。这种<strong>虚拟索引</strong>、<strong>物理标志</strong>的方法的局限性是直接映射缓存不能大于页大小。</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230606142539.png"></p>
<p>相联度可以将此索引保存在地址的物理部分，但仍支持大型缓存。</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230606143325.png"></p>
<p>由上面的公式可知，当相联度和缓存大小同时加倍并不会改变索引大小，比如IBM3033缓存是十六路组相联，尽管IBM体系结构中页大小为4KB，但这一高相联度仍允许使用物理索引对64KB的缓存进行寻址。</p>
<h3 id="B-3-7-小结"><a href="#B-3-7-小结" class="headerlink" title="B.3.7 小结"></a>B.3.7 小结</h3><p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230606143545.png"></p>
<h2 id="附加-缓存一致性"><a href="#附加-缓存一致性" class="headerlink" title="附加 缓存一致性"></a>附加 缓存一致性</h2><p>多核多处理器意味着在单芯片上有多个处理器，这些处理器可能会共享一个公共的物理地址空间。缓存共享数据带来了一个新的问题，由于两个不同的处理器所保存的存储器视图是通过各自的缓存得到的，如果没有其他的防范措施，两个处理器可能分别得到两个不同的值 。这个问题叫做<strong>缓存一致性</strong>问题，如果所示：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230606145015.png"></p>
<h3 id="附-1-缓存一致性协议的分类"><a href="#附-1-缓存一致性协议的分类" class="headerlink" title="附.1 缓存一致性协议的分类"></a>附.1 缓存一致性协议的分类</h3><p>缓存一致性协议的具体作用就是<strong>把某个处理器核新写的值传播给其他处理器核以确保所有处理器核看到一致的共享存储内容</strong>。从<strong>如何传播新值</strong>的角度看，缓存一致性协议可分为<strong>写无效</strong>（Write-Invalidate）（也可称为写使无效）协议与<strong>写更新</strong>（Write-Update）协议；从<strong>新值将会传播给谁</strong>的角度看，它可以分为<strong>监听协议</strong>与<strong>目录协议</strong>。缓存一致性协议决定系统为维护一致性所做的具体动作，因而直接影响系统性能。</p>
<p><strong>1）写无效协议与写更新协议。</strong></p>
<p>在写无效协议中，当根据一致性要求要把一个处理器核对某一单元所写的值传播给其他处理器核时，就使其他处理器核中该单元的备份无效；其他处理器核随后要用到该单元时，再获得该单元的新值。</p>
<p>在写更新协议中，当根据一致性要求要把一个处理器核对某一单元所写的值传播给其他处理器核时，就把该单元的新值传播给所有拥有该单元备份的处理器核，对相应的备份进行更新。</p>
<p>写无效协议的优点是：一旦某处理器核使某一变量在所有其他Cache中的备份无效后，它就取得了对此变量的独占权，随后它可以随意地更新此变量而不必告知其他处理器核，直到其他处理器核请求访问此变量而导致独占权被剥夺。其缺点是：当某变量在一处理器核中的备份变无效后，此处理器核再读此变量时会引起Cache不命中，在一个共享块被多个处理器核频繁访问的情况下会引起所谓的“乒乓”效应，即处理器核之间频繁地互相剥夺对一个共享块的访问权而导致性能严重下降。</p>
<p>写更新协议的优点是：一旦某Cache缓存了某一变量，它就一直持有此变量的最新备份，除非此变量被替换掉。其缺点是：写数的处理器核每次都得把所写的值传播给其他处理器核，即使其他处理器核不再使用所写的共享块。</p>
<p>写无效协议适用于顺序共享（Sequential Sharing）的程序，即在较长时间内只有一个处理器核访问一个变量；而写更新协议适用于紧密共享（Tight Sharing）的程序，即多个处理器核在一段时间内频繁地访问同一变量。</p>
<p><strong>2）监听协议与目录协议。</strong></p>
<p>监听协议的基本思想是，当一个处理器核对共享变量的访问不在Cache命中或可能引起数据不一致时，它就把这一事件广播到所有处理器核。系统中所有处理器核的Cache都监听广播，当拥有广播中涉及的共享变量的Cache监听到广播后，就采取相应的维持一致性的行动（如，使本Cache的备份无效、向总线提供数据等）。监听协议实现较简单，每个处理器核Cache只需要维护状态信息就可以了。监听协议适合于通过总线互连的多核处理器，因为总线是一种方便而快捷的广播媒介。在写使无效监听协议中，当一个Cache监听到其他处理器核欲写某一单元且自己持有此单元的备份时，就使这一备份无效以保持数据一致性；在写更新监听协议中，当一个Cache监听到自己持有备份的某一共享单元的内容被其他处理器核所更新时，就根据监听到的内容更新此备份的值。</p>
<p>由于监听协议需要广播，因此只适用于共享总线结构。总线是一种独占式资源，且总线延迟随所连接的处理器核数目的增加而增加，存在可伸缩性差的问题。在采用片上网络互连的多核处理器中通常使用基于目录的Cache一致性协议。</p>
<p>目录协议的主要思想是，为每一存储行维持一目录项，该目录项记录所有当前持有此行备份的处理器核号以及此行是否已被改写等信息。当一个处理器核欲往某一存储行写数且可能引起数据不一致时，它就根据目录的内容只向持有此行的备份的那些处理器核发出写使无效&#x2F;写更新信号，从而避免了广播。典型的目录组织方式为位向量目录。位向量目录中的每一目录项有一个n位的向量，其中n是系统中处理器核的个数。位向量中第i位为“1”表示此存储行在第i个处理器核中有备份。每一目录项还有一改写位，当改写位为“1”时表示某处理器核独占并已改写此行。位向量目录的缺点是，所需的目录存储器容量随处理器核数n以及共享存储容量m的增加以O(m*n)的速度增加，有较大存储开销。</p>
<h3 id="附-2-监听式和目录式"><a href="#附-2-监听式和目录式" class="headerlink" title="附.2 监听式和目录式"></a>附.2 监听式和目录式</h3><p>基于上面的协议，综合使用后，得到两种维持缓存一致性的方案，即<strong>监听式和目录式</strong>。在介绍这两种方法之前，我们还需介绍<strong>缓存状态</strong>，在缓存中每一个缓存行设置一致性状态来记录该缓存行的读写状态，确保缓存行不会被多个处理器核同时修改。缓存行的一致性状态的实现有多种具体形式，如最简单的三状态ESI，较为常见的MESI（修改，独占，共享，无效）及其变种MOESI等。如下图为ESI：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230606150002.png"></p>
<h4 id="监听式"><a href="#监听式" class="headerlink" title="监听式"></a>监听式</h4><p>我们通过一个例子来理解监听式是如何运作的：</p>
<blockquote>
<p>直接映射+写回法</p>
</blockquote>
<p><strong>CPU B读第5块</strong>：替换Cache B的块1，没有发生写回。整个过程为，Cache B发射<strong>Read Miss</strong>，存储器传输第5块到Cache B，Cache B的块1由<strong>无效</strong>转<strong>共享</strong>。</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230606151438.png"></p>
<p><strong>CPU C读第5块</strong>：替换Cache C的块1，没有发生写回。整个过程为，Cache C发射<strong>Read Miss</strong>，存储器传输第5块到Cache C，Cache C的块1由<strong>无效</strong>转<strong>共享</strong>。</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230606151545.png"></p>
<p><strong>CPU B写第5块</strong>：没有发生块替换，没有发生写回。整个过程为，CacheB发射Write Hit，总线发出作废请求，cache A和cache C中的块5由共享转<strong>无效</strong>，Cache B将新值写入自己的块1，状态由<strong>共享</strong>转<strong>独占</strong>。</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230606151015.png"></p>
<p><strong>CPU D读第5块</strong>：替换Cache D的块1，Cache B的块1写回。整个过程为，CacheD发射Read Miss，Cache B写回块5，存储器传输第5块到Cache D，Cache B的块1由<strong>独占</strong>转<strong>共享</strong>，Cache D的块1由<strong>无效</strong>转<strong>共享</strong>。</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230606151744.png"></p>
<h4 id="目录式"><a href="#目录式" class="headerlink" title="目录式"></a>目录式</h4><blockquote>
<p>直接映射+写回法</p>
<p>Presence bits指示了包含该块copy的CPU</p>
</blockquote>
<p><strong>CPU A读第6块</strong>：Cache A发送Read Miss(A,6)到Memory A，Memory A传输第6块到Cache A，Cache A的块2由<strong>无效</strong>转<strong>共享</strong>。</p>
<p>MemoryA的块6：State:未缓冲-&gt;共享，Presence bits:0000-&gt;0001，共享集合{A}。</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230606152823.png"></p>
<p><strong>CPU B读第6块</strong>：Cache B发送Read Miss(B,6)到Memory A，Memory A传输第6块到Cache B，Cache B的块2由<strong>无效</strong>转<strong>共享</strong>。</p>
<p>MemoryA的块6，State:共享-&gt;共享，Presence bits:0001-&gt;0011，共享集合{A，B}</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230606153231.png"></p>
<p><strong>CPU D读第6块</strong>：Cache D发送Read Miss(D,6)到Memory A，Memory A传输第6块到Cache D，Cache D的块2由<strong>无效</strong>转<strong>共享</strong>。</p>
<p>MemoryA的块6，State:共享-&gt;共享，Presence bits:0011-&gt;1011，共享集合{A，B，D}</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230606153342.png"></p>
<p><strong>CPU B写第6块</strong>：Cache B发送Write Hit(B,6)(Invalidate)到Memory A，Memory A发送Invalidate(6)到Cache A，Cache A的块2由<strong>共享</strong>转<strong>无效</strong>，Memory A发送Invalidate(6)到Cache D，Cache D的块2由<strong>共享</strong>转<strong>无效</strong>，Cache B的块2由<strong>共享</strong>转<strong>独占</strong>。</p>
<p>MemoryA的块6，State:共享-&gt;独占，Presence bits:1011-&gt;0010，共享集合{B}</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230606153504.png"></p>
<p><strong>CPU C读第6块</strong>：Cache C发送Read Miss(C,6)到Memory A，Memory A发送Fetch(6)到Cache B，Cache B传输第6块到Memory A，即写回。Cache B的块2由独占转<strong>共享</strong>，Memory A传输第6块到Cache C，Cache C的块2由<strong>无效</strong>转<strong>共享</strong>。</p>
<p>MemoryA的块6，State:独占-&gt;共享，Presence bits:0010-&gt;0110，共享集合{B，C}</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230606153715.png"></p>
<h4 id="二者比较"><a href="#二者比较" class="headerlink" title="二者比较"></a>二者比较</h4><p>监听法：</p>
<ul>
<li>优点：小型体系中，总线的交流很少，不会把太多时间浪费在不同宿主的沟通之间。</li>
<li>缺点：对于CPU数量多的架构，总线压力会很大，性能下降很快。</li>
</ul>
<p>目录法：</p>
<ul>
<li>优点：可以支持大型体系，扩展性更强。</li>
<li>缺点：宿主与缓存的沟通次数多，对于多写的操作序列不友好。并且需要额外存储空间存储Presence Bits，当处理器数目较多时存储开销过大。</li>
</ul>
<h1 id="C-流水线"><a href="#C-流水线" class="headerlink" title="C. 流水线"></a>C. 流水线</h1><h2 id="C-1-流水线基础概念"><a href="#C-1-流水线基础概念" class="headerlink" title="C.1 流水线基础概念"></a>C.1 流水线基础概念</h2><p>流水线是一种将多条指令重叠执行的实现技术。一条指令的执行需要多个操作，流水线技术充分利用了这些操作之间的并行性。流水线的<strong>吞吐量</strong>由指令退出流水线的频率决定，<strong>处理器周期</strong>是一条指令在流水线中下移一步所需的时间。</p>
<p>在RISC子集中的每条指令都可以在最多5个时钟周期内实现。这5个时钟周期如下所述：</p>
<ul>
<li><strong>指令提取周期（IF）</strong>：将程序计数器（PC）发送到存储器，从存储器提取当前指令。向程序计数器加4，将程序计数器更新到下一个连续程序计数器。</li>
<li><strong>指令译码&#x2F;寄存器提取周期（ID）</strong>：对指令进行译码，并从寄存器堆中读取与寄存器源说明符相对应的寄存器。</li>
<li><strong>执行&#x2F;有效地址周期（EX）</strong>：ALU对上一周期准备的操作数进行操作，根据指令类型执行三条指令之一（存储器引用&#x2F;寄存器-寄存器ALU指令&#x2F;寄存器-立即数ALU指令）。</li>
<li><strong>存储器访问（MEM）</strong>：如果该条指令是一条载入指令，则使用上一周期计算的有效地址从存储器中读取数据。如果是一条存储指令，则使用有效地址将从寄存器堆的第二个寄存器读取的数据写入存储器。</li>
<li><strong>写回周期（WB）</strong>：将结果写入寄存器堆，无论是来自寄存器系统（对于载入指令），还是来自ALU（对于ALU指令）。</li>
</ul>
<blockquote>
<p>程序计数器（PC，Program counter），用于存放指令的地址。<br>指令寄存器（IR，Instruction Register），用来保存当前正在执行的一条指令。<br>指令译码器（ID，Instruction Decoder），对指令进行译码，然后将该指令发送到对应的部件。</p>
</blockquote>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230602193953.png"></p>
<h2 id="C-2-流水线冒险"><a href="#C-2-流水线冒险" class="headerlink" title="C.2 流水线冒险"></a>C.2 流水线冒险</h2><ul>
<li><strong>结构冒险</strong>：在重叠执行模式下，如果硬件无法同时支持指令的所有可能组合方式，就会出现资源冲突，从而导致结构冒险。</li>
<li><strong>数据冒险</strong>：根据流水线中的指令重叠，指令之间存在先后顺序，如果一条指令取决于先前指令的结果，就可能导致数据冒险。</li>
<li><strong>控制冒险</strong>：分支指令及其他改变了程序计数器的指令实现流水化可能导致控制冒险。</li>
</ul>
<h3 id="C-2-1-带有停顿的流水线性能"><a href="#C-2-1-带有停顿的流水线性能" class="headerlink" title="C.2.1 带有停顿的流水线性能"></a>C.2.1 带有停顿的流水线性能</h3><p>首先看流水化加速比最原始的公式： <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164648.png"></p>
<p>对流水化CPI进行分析，其中理想CPI总是等于1： <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164654.png"></p>
<p>将二者合一，且如果将流水化看作时钟周期时间的改善，那么可以假定<strong>非流水化处理器的CPI为1</strong>。并且当流水级达到完美平衡时，<strong>非流水化时钟周期&#x2F;流水化时钟周期&#x3D;流水线深度（流水级数目）</strong>，因此最后得到如下公式： <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164701.png"></p>
<p>因此不难看出如果没有停顿，则加速比等于流水级数。</p>
<h3 id="C-2-2-结构冒险"><a href="#C-2-2-结构冒险" class="headerlink" title="C.2.2 结构冒险"></a>C.2.2 结构冒险</h3><p><strong>结构冒险</strong>常见于某功能单元未能完全流水化的情况，另一常见出现方式是某一资源的复制不足以执行流水线中的所有指令组合，即硬件不支持多条指令在同一时钟周期内执行。如处理器可能仅有一个寄存器堆写端口，但在特定情况下，流水线可能希望在一个时钟周期内执行两个写操作，这就产生了结构冒险。精准定义就是<strong>因缺乏硬件支持而导致指令不能在预定的时钟周期内执行的情况</strong>。</p>
<p>为避免这一冒险，在发生数据存储器访问时，我们使流水线停顿一个时钟周期。<strong>停顿</strong>或<strong>阻塞</strong>通常被称为<strong>流水线气泡</strong>或称为<strong>气泡</strong>，因为它会漂浮穿过流水线，占据空间却不执行有用工作。</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164710.png"></p>
<h3 id="C-2-2-数据冒险"><a href="#C-2-2-数据冒险" class="headerlink" title="C.2.2 数据冒险"></a>C.2.2 数据冒险</h3><p>当流水线改变对操作数的读写访问顺序，使该顺序不同于在非流水化处理器上依次执行指令时的顺序，这时可能发生数据冒险。精确定义就是<strong>因无法提供指令执行数据而导致指令不能在预定的时钟周期内执行的情况。</strong></p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164718.png"></p>
<p>我们可以用<strong>转发</strong>技术将数据冒险停顿减至最少，转发即旁路，其关键是认识到DSUB要等到DADD实际生产结果之后才会用到它（上面的例子）。转发的工作方式如下：</p>
<ul>
<li>来自EX&#x2F;MEM和MEM&#x2F;WB流水线寄存器的ALU结果总是被反馈回ALU的输入端。</li>
<li>如果转发硬件检测到前一个ALU操作已经对当前ALU操作的源寄存器进行了写入操作，则控制逻辑选择转发结果作为ALU输入，而不是选择从寄存器堆中读取的值。 <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164726.png"></li>
</ul>
<p>但不是所有数据冒险都能通过转发解决，比如对于RAW冒险，指令间有数据依赖。载入指令有一种不能单由转发来消除的延迟，因此需要增加一种称为<strong>流水线互锁</strong>，以保持正确的执行模式。流水线互锁会检测冒险，并在该冒险被清除之前使流水线停顿。在这种情况下，互锁使流水线停顿，让希望使用的某一数据的指令等待，直到源指令生成该数据为止。</p>
<p>如图会发生在“负向时间”上转发结果，因此在CC4这里后面三个指令都要停顿。 <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164734.png"></p>
<h3 id="C-2-3-分支冒险"><a href="#C-2-3-分支冒险" class="headerlink" title="C.2.3 分支冒险"></a>C.2.3 分支冒险</h3><p>对于MIPS流水线，控制冒险造成的性能损失可能比数据冒险还要大。这种冒险会出现在以下情况：决策依赖于一条指令的结果，而其他指令正在执行中。精确定义为就是<strong>取到的指令并不是所需要的（或者说指令地址的变化并不是流水线所预期的）而导致指令不能在预定的时钟周期内执行。</strong></p>
<p>在执行分支时，修改后的程序计数器的值可能等于（也可能不等于）当前值+4。如果分支将程序计数器改为其目标地址，它就是选中分支；否则就是未选中分支，如果指令i为选中分支，通常会等到ID末尾，完成地址计算和对比之后才会改变程序计数器。</p>
<p>处理分支最简单的方法就是一旦在ID期间检测到分支，就对该分支之后的指令重新取值。第一个IF周期基本上是一次停顿，因此它从不执行有用工作。但是如果分支未被选中，由于事实上已经正确提取了指令，所以IF级的重复是不必要的，针对这一点需要优化。 <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164743.png"></p>
<p>如果每个分支产生一个停顿周期，将会使性能损失10%~30%，具体取决于分支频率，所以需要一些技术来出来由分支延迟导致的流水线停顿。</p>
<blockquote>
<p>以下四种处理机制中，分支的操作都是静态的</p>
</blockquote>
<h4 id="（1）降低流水线分支代价"><a href="#（1）降低流水线分支代价" class="headerlink" title="（1）降低流水线分支代价"></a>（1）降低流水线分支代价</h4><p>最简单的机制就是<strong>冻结或冲刷流水线</strong>，保留或删除分支之后的所有指令，直到知道分支目标为止。这种机制其软硬件都很简单。</p>
<p>另一种性能更高但更复杂的机制就是将<strong>每个分支都看作未选中分支（预测未选中机制）</strong>，允许硬件继续执行，就像该分支未被执行一样。其实现方式是继续提取指令，就像分支指令是一条正常指令一样。但如果分支被选中，就需要将已提取的指令转为空操作，重新开始在目标地址提取指令。</p>
<p>一种替代机制是<strong>将所有分支都看作选中分支（预测选中机制）</strong>。只要对分支指令进行译码并计算了目标地址，我们就假定该分支被选中，开始在目标位置提取和执行。在MIPS的五级流水线中，因为不可能在分支输出结果之前知道目标地址，因此这种方式对这一类型的流水线无用，但在一些处理器中能发挥作用。</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164752.png"></p>
<p>最后一个机制被称为<strong>延迟分支</strong>，在延迟分支中，带有一个分支延迟的执行周期为： <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164801.png"></p>
<p>依序后续指令位于分支延迟时隙中。无论该分支是否被选中，这一指令都会执行。尽管分支延迟可能长于一个时钟周期，但在实际中几乎所有具有延迟分支的处理器都只有单个指令延迟。如果流水线潜在分支代价更长，那么则使用其他技术。 <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164810.png"></p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164817.png"></p>
<p>延迟分支调度的局限在于：对于可排在延迟时隙中的指令有限制。在编译时预测一个分支是否可能被选中的能力有限。</p>
<h4 id="（2）分支机制的性能"><a href="#（2）分支机制的性能" class="headerlink" title="（2）分支机制的性能"></a>（2）分支机制的性能</h4><blockquote>
<p>假定理想CPI为1</p>
</blockquote>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164825.png"></p>
<h4 id="（3）通过预测降低分支成本"><a href="#（3）通过预测降低分支成本" class="headerlink" title="（3）通过预测降低分支成本"></a>（3）通过预测降低分支成本</h4><p>当流水线越来越深，分支的潜在代价增加，需要新的机制来解决。这些机制分为两类，一种是依赖编译时可用信息的低成本<strong>静态</strong>机制，另一种是根据程序特性对分支进行<strong>动态</strong>预测的策略。</p>
<p>改进编译时分支预测的一种重要方式就是利用先前运行过程收集的一览数据，根据数据得到的分支行为特性来预测。</p>
<p>动态分支预测机制则是现在的主流机制，最简单一种就是分支预测缓冲区或者分支历史表。分支预测缓冲区是一个小型存储器，根据分支指令地址的低位部分进行索引。这个存储器中包含一个位，表明该分支最近是否曾被选中。这一机制是最简单的缓冲区形式，没有标志，仅当分支延迟过长，超过可能目标PC计算所需要的时间时，用于缩短分支延迟。一位预测机制有一个明显短板，即使某个分支几乎总是被选中，在其未被选中时，我们也可能会得到两次错误预测，而不是一次，因为错误预测会导致该预测位反转。因此实际一般经常采用两位预测机制。 <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164945.png"> <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164952.png"></p>
<h2 id="C-3-流水化的实现"><a href="#C-3-流水化的实现" class="headerlink" title="C.3 流水化的实现"></a>C.3 流水化的实现</h2><h3 id="C-3-1-非流水化简单实现"><a href="#C-3-1-非流水化简单实现" class="headerlink" title="C.3.1 非流水化简单实现"></a>C.3.1 非流水化简单实现</h3><p>我们先回顾一下MIPS非流水版本的简单实现。 <strong>①指令提取周期（IF）</strong>：从PC中获取指令的地址，然后从内存中读取指令并放到IR中，PC+4。于此类似的是，寄存器NPC用于保存下一顺序的PC。 <strong>②指令译码&#x2F;寄存器提取周期（ID）</strong>：对该指令进行译码并访问寄存器堆，以读取寄存器。通用寄存器的输出被读入两个临时寄存器中，供后续时钟周期使用。IR的低16位也进行符号扩展，存储在临时寄存器Imm中，供下一个周期使用。（MIPS中指令译码和寄存器提取周期可以并行完成）。 <strong>③执行&#x2F;实际地址周期（EX）</strong>：ALU对前一周期准备的操作数进行操作，根据MIPS指令类型执行以下4种功能之一——存储器引用&#x2F;寄存器-寄存器ALU指令&#x2F;寄存器-立即数ALU指令&#x2F;分支。（MIPS的载入-存储体系结构意味着实际地址和执行周期可以合并到一个时钟周期中）。 <strong>④存储器访问&#x2F;分支完成计算（MEM）</strong>：对所有指令更新PC：PC &lt;– NPC <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527164958.png"> <strong>⑤写回周期（WB）</strong>： <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527165008.png"></p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527165014.png"></p>
<h3 id="C-3-2-MIPS基本流水线"><a href="#C-3-2-MIPS基本流水线" class="headerlink" title="C.3.2 MIPS基本流水线"></a>C.3.2 MIPS基本流水线</h3><p>只要在每个时钟周期启动一个新指令，几乎不用改变什么就可以对图C-13的数据路径实现流水线。此外，数据路径的流水化要求必须将流水级之间传递的数值放在寄存器中。图C-14中，流水级之间的寄存器称为<strong>流水线寄存器</strong>或<strong>流水线锁存器</strong>。用于在一条指令的时钟周期之间保存临时值的所有寄存器都包含在这些流水线寄存器中，它们用于从一个流水级向下一个流水级传送数据和控制。 <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527165025.png"></p>
<h3 id="C-3-3-MIPS流水线的控制"><a href="#C-3-3-MIPS流水线的控制" class="headerlink" title="C.3.3 MIPS流水线的控制"></a>C.3.3 MIPS流水线的控制</h3><p>将一条指令从指令译码级（ID）转移到流水线执行级（EX）的过程称之为<strong>指令发射</strong>。已经执行的指令称为<strong>已发射</strong>。对于MIPS整数流水线，所有数据冒险都可以在流水线的ID阶段进行检查，如存在数据冒险，则指令在被发射前会停顿。与此类似，我们可以确定在ID期间需要哪种转发，并设定适当的控制。检查冒险和转发是两种方法，接下来展示如何通过在ID中进行检查来消除因为载入指令所导致的写后读（RAW）冒险互锁（载入互锁）。 <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527165033.png"></p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527165039.png"></p>
<p>一旦检测到冒险，控制单元必须插入流水线停顿，并防止IF和ID级中的指令继续前进。由于所有控制信息都承载于流水线寄存器中，因此检测冒险时，只需将ID&#x2F;EX流水线寄存器的控制部分改为全0，即空操作。此外，循环使用IF&#x2F;ID寄存器中的内容，以保存被停顿的指令。</p>
<p>而转发逻辑的实现需要考虑更多情况，但大体实现类似。关键在于注意到流水线寄存器中既包含了要转发的数据，也包含了源、目标寄存器字段。所有转发在逻辑上都是从ALU或数据存储器的输出到ALU输出、数据存储器输入或零检测单元。因此对比EX&#x2F;MEM和MEM&#x2F;WB级中所包含IR的目标寄存器与ID&#x2F;EX和EX&#x2F;MEM寄存器中所包含IR的源寄存器，以此来实现转发。</p>
<h3 id="C-3-4-流水线中的分支"><a href="#C-3-4-流水线中的分支" class="headerlink" title="C.3.4 流水线中的分支"></a>C.3.4 流水线中的分支</h3><p>在MIPS中，分支（BEQ和BNE）需要检测一个寄存器，看其是否等于另一个寄存器（该寄存器可能为R0）。如果仅考虑BEQZ和BNEZ的情景（它们需要零检测），那有可能通过将零检测移到周期内部，在ID周期结束时完成此判断。为了充分利用尽早判断出该分支是否命中的优势，都必须尽早计算PC（无论是否命中）。在ID期间计算分支目标地址需要增加一个加法器，因为前面一直用于实现功能的主ALU在EX之前是不可用的。通过增加独立的加法器，并在ID期间作出分支判断，分支仅需要停顿一个时钟周期。尽管这样将分支延迟缩减为一个周期，但这意味着如果一个ALU指令后面跟有一个依赖该指令结果的分支，那就会招致数据冒险停顿。</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527165049.png"></p>
<h3 id="C-3-5-流水线性能"><a href="#C-3-5-流水线性能" class="headerlink" title="C.3.5 流水线性能"></a>C.3.5 流水线性能</h3><p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527165057.png"> <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527165103.png"> <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527165110.png"> <img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230527165116.png"></p>
<h2 id="C-7-交叉问题（ScoreBoard）"><a href="#C-7-交叉问题（ScoreBoard）" class="headerlink" title="C.7 交叉问题（ScoreBoard）"></a>C.7 交叉问题（ScoreBoard）</h2><p>一个典型RISC体系结构需要四条指令（两条载入指令、一条加法指令和一条存储指令），在大多数流水线中，不可能在没有插入停顿的情况下顺序调度这些指令。但是对于RISC来说，每个操作都是单独指令，可以对流水线进行调度以达到更高的效率。使用编译器进行调度则是<strong>静态调度</strong>，依赖硬件进行调度则是<strong>动态调度</strong>。</p>
<h3 id="ScoreBoard算法"><a href="#ScoreBoard算法" class="headerlink" title="ScoreBoard算法"></a>ScoreBoard算法</h3><p>由于顺序执行的处理器的性能存在缺陷（试想一下，当某个指令被阻塞，它后面的指令也被阻塞，严重影响性能），因此现代处理器都支持乱序执行，即<strong>指令在执行过程中不按照指令顺序执行</strong>。在乱序情况下，只要一条指令所需要的数据准备好了，那么就执行这条指令，而不用像顺序执行一样既要准备好数据，又要前面的指令把“路”让出来。而ScoreBoard算法就是一个乱序执行的算法，基于硬件对指令进行动态调度。</p>
<p><img src="https://pic1.zhimg.com/80/v2-27e9fa6628291e3aabc8f1dafacd79a8_1440w.webp"></p>
<p>ScoreBoard算法的核心在于在原先流水线的基础上，添加了一个硬件部件ScoreBoard（记分牌），它用来记录各个功能部件的使用情况以便每条指令来根据此来判断是否可以执行。ScoreBoard分为三个部分：</p>
<ul>
<li>Instruction Status——记录正在执行的各条指令所处的状态步。</li>
</ul>
<p>   <img src="https://img-blog.csdnimg.cn/20200425112005790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FuZ3VzX2h1YW5nX3h1,size_16,color_FFFFFF,t_70"></p>
<ul>
<li>Functional unit status——记录功能部件(FU)的状态。</li>
</ul>
<table>
<thead>
<tr>
<th>Busy</th>
<th>Op</th>
<th>Fi</th>
<th>Fj</th>
<th>Fk</th>
<th>Qj</th>
<th>Qk</th>
<th>Rj</th>
<th>Rk</th>
</tr>
</thead>
<tbody><tr>
<td>指示部件是否空闲</td>
<td>该部件的操作</td>
<td>目的寄存器编号</td>
<td>源寄存器1编号</td>
<td>源寄存器2编号</td>
<td>源操作数1的产生部件</td>
<td>源操作数2的产生部件</td>
<td>源操作数1是否就绪</td>
<td>源操作数2是否就绪</td>
</tr>
</tbody></table>
<p><img src="https://img-blog.csdnimg.cn/20200425111946249.png"></p>
<ul>
<li>Register result status ——如果存在功能部件对某一寄存器进行写操作， 指示具体是哪个功能部件对该寄存器进行写操作。如果没有指令对该寄存器进行写操作， 则该域为Blank</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200425111917423.png"></p>
<p>使用ScoreBoard算法一个指令需要经历四个执行步骤（主要考虑浮点运算，不考虑存储器访问步骤）：</p>
<ul>
<li><p>Issue（发射）：<strong>指令译码，检测结构相关</strong>。检测当前指令所需的<strong>功能部件</strong>（如整数乘法器，浮点数乘法器等）是否空闲，检测当前指令的<strong>目的寄存器</strong>是否被其他指令作为目的寄存器占用（通过这一步解决了<strong>WAW</strong>相关）。若两者有一不满足，则停止发射当前指令，也不发射后续指令（这就保证了顺序发射，顺序发射可以让我们知道某条指令的结果会流向哪些指令，如果不顺序发射，可能会混淆RAW和WAR相关）。</p>
</li>
<li><p>Read（取数）：通过scoreboard检测当前指令需要的<strong>源寄存器</strong>是否被其他已发射指令寄存器作为目的寄存器占用。如果没有，则读取相应的值作为操作数，否则该条指令stall（停止），让后面指令先执行（这一步解决<strong>RAW</strong>相关，同时导致了乱序执行）。</p>
</li>
<li><p>Exec（执行）：接收到操作数后，相应的功能部件开始执行；当计算完成后，通知scoreboard可以结束此指令的执行，释放指令对改功能部件的占用。</p>
</li>
<li><p>Write（写回）：scoreboard得到执行结束的消息后，检测指令的写回寄存器是否被作为源寄存器读取，即检测<strong>WAR</strong>相关。如有<strong>WAR</strong>相关，就暂停该指令；没有就正常写回。</p>
</li>
</ul>
<p>如图为例，列举部分周期ScoreBoard的变化：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230602204103.png"></p>
<p>第一个时钟周期：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230602204121.png"></p>
<p>第二个时钟周期：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230602204201.png"></p>
<p>第三个时钟周期：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230602204339.png"></p>
<p>第四个时钟周期：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230602204434.png"></p>
<p>第五个时钟周期：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230602204451.png"></p>
<p>第六个时钟周期：</p>
<p><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/PicGo20230602204514.png"></p>
<p>综上我们可以对ScoreBoard算法做一个总结，它是顺序发射，乱序执行的一个算法，精确地监控了WAR，RAW，WAW这三种数据冒险。当然它也存在很明显的缺陷，WAR和WAW实际上都是假冒险，解决假冒险可以通过寄存器重命名实现，没必要因此停顿流水线从而影响性能。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://yeyuhl.github.io">夜语</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yeyuhl.github.io/2023/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">https://yeyuhl.github.io/2023/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yeyuhl.github.io" target="_blank">随便写写</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/%E7%89%B9%E5%AE%9A%E6%96%87%E4%BB%B6/1a14e4eeedd428147c921881097b3aed8a932201.jpg%40942w_942h_progressive.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/12/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="编译原理期末复习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">编译原理期末复习</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://yeyu-1313730906.cos.ap-guangzhou.myqcloud.com/%E7%89%B9%E5%AE%9A%E6%96%87%E4%BB%B6/1a14e4eeedd428147c921881097b3aed8a932201.jpg%40942w_942h_progressive.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">夜语</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yeyuhl"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">随便写写的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E9%87%8F%E5%8C%96%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80"><span class="toc-text">1. 量化设计与分析基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E8%83%BD%E8%80%97-Energy-%E4%B8%8E%E5%8A%9F%E7%8E%87-Power"><span class="toc-text">1.5 能耗(Energy)与功率(Power)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E8%8A%AF%E7%89%87%E6%88%90%E6%9C%AC"><span class="toc-text">1.6 芯片成本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E5%8F%AF%E4%BF%A1%E4%BB%BB%E5%BA%A6"><span class="toc-text">1.7 可信任度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AE%BE%E8%AE%A1%E7%9A%84%E9%87%8F%E5%8C%96%E5%8E%9F%E7%90%86"><span class="toc-text">1.9 计算机设计的量化原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-1-%E4%B8%89%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-text">1.9.1 三大设计原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-2-Amdahl%E5%AE%9A%E5%BE%8B"><span class="toc-text">1.9.2 Amdahl定律</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-3-%E5%A4%84%E7%90%86%E5%99%A8%E6%80%A7%E8%83%BD%E5%85%AC%E5%BC%8F"><span class="toc-text">1.9.3 处理器性能公式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C%E5%8F%8A%E5%85%B6%E5%BC%80%E5%8F%91"><span class="toc-text">3. 指令级并行及其开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">3.1 指令级并行的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3%E4%B8%8E%E5%86%92%E9%99%A9"><span class="toc-text">3.1.1 数据相关与冒险</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3"><span class="toc-text">（1）数据相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%90%8D%E7%A7%B0%E7%9B%B8%E5%85%B3"><span class="toc-text">（2）名称相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9"><span class="toc-text">（3）数据冒险</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3"><span class="toc-text">3.1.2 控制相关</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%8F%AD%E7%A4%BAILP%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%96%E8%AF%91%E5%99%A8%E6%8A%80%E6%9C%AF"><span class="toc-text">3.2 揭示ILP的基本编译器技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E5%9F%BA%E6%9C%AC%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%B0%83%E5%BA%A6%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80"><span class="toc-text">3.2.1 基本流水线调度和循环展开</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E7%94%A8%E9%AB%98%E7%BA%A7%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E9%99%8D%E4%BD%8E%E5%88%86%E6%94%AF%E6%88%90%E6%9C%AC"><span class="toc-text">3.3 用高级分支预测降低分支成本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E7%94%A8%E5%8A%A8%E6%80%81%E8%B0%83%E5%BA%A6%E5%85%8B%E6%9C%8D%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9"><span class="toc-text">3.4 用动态调度克服数据冒险</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E5%8A%A8%E6%80%81%E8%B0%83%E5%BA%A6%E7%9A%84%E6%80%9D%E6%83%B3"><span class="toc-text">3.4.1 动态调度的思想</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Tomasulo%E7%AE%97%E6%B3%95"><span class="toc-text">3.5 Tomasulo算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-Tomasulo%E7%AE%97%E6%B3%95%EF%BC%9A%E5%9F%BA%E4%BA%8E%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%B1%95%E7%A4%BA"><span class="toc-text">3.5.1 Tomasulo算法：基于循环的展示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#A-%E6%8C%87%E4%BB%A4%E9%9B%86%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text">A. 指令集基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-1-%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">A.1 指令集体系结构的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-2-%E5%AD%98%E5%82%A8%E5%99%A8%E5%AF%BB%E5%9D%80"><span class="toc-text">A.2 存储器寻址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-3-%E6%8C%87%E4%BB%A4%E9%9B%86%E7%BC%96%E7%A0%81"><span class="toc-text">A.3 指令集编码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#B-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-text">B. 存储器层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#B-1-%E7%BC%93%E5%AD%98%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">B.1 缓存的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B-1-1-%E5%9D%97%E7%9A%84%E6%94%BE%E7%BD%AE%EF%BC%88%E7%BC%93%E5%AD%98%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-text">B.1.1 块的放置（缓存组织方式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-1-2-%E5%9D%97%E7%9A%84%E8%AF%86%E5%88%AB"><span class="toc-text">B.1.2 块的识别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-1-3-%E5%9D%97%E7%9A%84%E6%9B%BF%E6%8D%A2"><span class="toc-text">B.1.3 块的替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-1-4-%E5%86%99%E5%85%A5%E7%AD%96%E7%95%A5"><span class="toc-text">B.1.4 写入策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-2-%E7%BC%93%E5%AD%98%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-text">B.2 缓存的性能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B-2-1-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B9%B3%E5%9D%87%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4%E5%92%8C%E5%A4%84%E7%90%86%E5%99%A8%E6%80%A7%E8%83%BD"><span class="toc-text">B.2.1 存储器平均访问时间和处理器性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-2-2-%E7%BC%BA%E5%A4%B1%E4%BB%A3%E4%BB%B7%E5%92%8C%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">B.2.2 缺失代价和乱序执行处理器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-3-6%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96"><span class="toc-text">B.3 6种基本的缓存优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B-3-1-%E7%AC%AC%E4%B8%80%E7%A7%8D%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%EF%BC%9A%E5%A2%9E%E5%A4%A7%E5%9D%97%E5%A4%A7%E5%B0%8F%E4%BB%A5%E9%99%8D%E4%BD%8E%E7%BC%BA%E5%A4%B1%E7%8E%87"><span class="toc-text">B.3.1 第一种优化方法：增大块大小以降低缺失率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-3-2-%E7%AC%AC%E4%BA%8C%E7%A7%8D%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%EF%BC%9A%E5%A2%9E%E5%A4%A7%E7%BC%93%E5%AD%98%E4%BB%A5%E9%99%8D%E4%BD%8E%E7%BC%BA%E5%A4%B1%E7%8E%87"><span class="toc-text">B.3.2 第二种优化方法：增大缓存以降低缺失率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-3-3-%E7%AC%AC%E4%B8%89%E7%A7%8D%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%EF%BC%9A%E6%8F%90%E9%AB%98%E7%9B%B8%E8%81%94%E5%BA%A6%E4%BB%A5%E9%99%8D%E4%BD%8E%E7%BC%BA%E5%A4%B1%E7%8E%87"><span class="toc-text">B.3.3 第三种优化方法：提高相联度以降低缺失率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-3-4-%E7%AC%AC%E5%9B%9B%E7%A7%8D%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%EF%BC%9A%E9%87%87%E7%94%A8%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E9%99%8D%E4%BD%8E%E7%BC%BA%E5%A4%B1%E4%BB%A3%E4%BB%B7"><span class="toc-text">B.3.4 第四种优化方法：采用多级缓存降低缺失代价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-3-5-%E7%AC%AC%E4%BA%94%E7%A7%8D%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%EF%BC%9A%E4%BD%BF%E8%AF%BB%E5%8F%96%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E9%AB%98%E4%BA%8E%E5%86%99%E5%85%A5%E7%BC%BA%E5%A4%B1%EF%BC%8C%E4%BB%A5%E9%99%8D%E4%BD%8E%E7%BC%BA%E5%A4%B1%E4%BB%A3%E4%BB%B7"><span class="toc-text">B.3.5 第五种优化方法：使读取缺失的优先级高于写入缺失，以降低缺失代价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-3-6-%E7%AC%AC%E5%85%AD%E7%A7%8D%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%EF%BC%9A%E9%81%BF%E5%85%8D%E5%9C%A8%E7%B4%A2%E5%BC%95%E7%BC%93%E5%AD%98%E6%9C%9F%E9%97%B4%E8%BF%9B%E8%A1%8C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%EF%BC%8C%E4%BB%A5%E7%BC%A9%E7%9F%AD%E5%91%BD%E4%B8%AD%E6%97%B6%E9%97%B4"><span class="toc-text">B.3.6 第六种优化方法：避免在索引缓存期间进行地址转换，以缩短命中时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-3-7-%E5%B0%8F%E7%BB%93"><span class="toc-text">B.3.7 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%8A%A0-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">附加 缓存一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84-1-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">附.1 缓存一致性协议的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84-2-%E7%9B%91%E5%90%AC%E5%BC%8F%E5%92%8C%E7%9B%AE%E5%BD%95%E5%BC%8F"><span class="toc-text">附.2 监听式和目录式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%BC%8F"><span class="toc-text">监听式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E5%BC%8F"><span class="toc-text">目录式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%80%85%E6%AF%94%E8%BE%83"><span class="toc-text">二者比较</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-text">C. 流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-1-%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-text">C.1 流水线基础概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-2-%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%86%92%E9%99%A9"><span class="toc-text">C.2 流水线冒险</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-2-1-%E5%B8%A6%E6%9C%89%E5%81%9C%E9%A1%BF%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%80%A7%E8%83%BD"><span class="toc-text">C.2.1 带有停顿的流水线性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-2-2-%E7%BB%93%E6%9E%84%E5%86%92%E9%99%A9"><span class="toc-text">C.2.2 结构冒险</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-2-2-%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9"><span class="toc-text">C.2.2 数据冒险</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-2-3-%E5%88%86%E6%94%AF%E5%86%92%E9%99%A9"><span class="toc-text">C.2.3 分支冒险</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%99%8D%E4%BD%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%88%86%E6%94%AF%E4%BB%A3%E4%BB%B7"><span class="toc-text">（1）降低流水线分支代价</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%88%86%E6%94%AF%E6%9C%BA%E5%88%B6%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-text">（2）分支机制的性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E9%80%9A%E8%BF%87%E9%A2%84%E6%B5%8B%E9%99%8D%E4%BD%8E%E5%88%86%E6%94%AF%E6%88%90%E6%9C%AC"><span class="toc-text">（3）通过预测降低分支成本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-3-%E6%B5%81%E6%B0%B4%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">C.3 流水化的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-3-1-%E9%9D%9E%E6%B5%81%E6%B0%B4%E5%8C%96%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">C.3.1 非流水化简单实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-3-2-MIPS%E5%9F%BA%E6%9C%AC%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-text">C.3.2 MIPS基本流水线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-3-3-MIPS%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-text">C.3.3 MIPS流水线的控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-3-4-%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B8%AD%E7%9A%84%E5%88%86%E6%94%AF"><span class="toc-text">C.3.4 流水线中的分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-3-5-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%80%A7%E8%83%BD"><span class="toc-text">C.3.5 流水线性能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-7-%E4%BA%A4%E5%8F%89%E9%97%AE%E9%A2%98%EF%BC%88ScoreBoard%EF%BC%89"><span class="toc-text">C.7 交叉问题（ScoreBoard）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ScoreBoard%E7%AE%97%E6%B3%95"><span class="toc-text">ScoreBoard算法</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="计算机体系结构期末复习">计算机体系结构期末复习</a><time datetime="2023-12-25T08:52:19.000Z" title="发表于 2023-12-25 16:52:19">2023-12-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/25/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="编译原理期末复习">编译原理期末复习</a><time datetime="2023-12-25T08:38:35.000Z" title="发表于 2023-12-25 16:38:35">2023-12-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/27/Redis%E8%A7%A3%E6%9E%90/" title="Redis 解析">Redis 解析</a><time datetime="2023-09-27T11:21:56.000Z" title="发表于 2023-09-27 19:21:56">2023-09-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/13/SimpleDB/" title="SimpleDB">SimpleDB</a><time datetime="2023-09-13T08:16:35.000Z" title="发表于 2023-09-13 16:16:35">2023-09-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/13/RaftKV/" title="RaftKV">RaftKV</a><time datetime="2023-09-13T08:14:29.000Z" title="发表于 2023-09-13 16:14:29">2023-09-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 夜语</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>